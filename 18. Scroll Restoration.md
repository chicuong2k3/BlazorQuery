# Scroll Restoration

Traditionally, when you navigate to a previously visited page in a web application, you would find that the page would be scrolled to the exact position where you were before you navigated away from that page. This is called **scroll restoration** and has been in a bit of a regression since web applications have started moving towards client-side data fetching. With BlazorQuery however, that's no longer the case.

BlazorQuery doesn't implement scroll restoration by itself, but it removes one of the biggest causes of broken restoration in SPAs: refetch-induced UI resets. By keeping previously fetched data in cache (and optionally using `placeholderData`), navigation back to a page can render instantly with stable layout, making scroll restoration reliable when handled by the framework (e.g., Blazor's NavigationManager, custom scroll management, or browser's native scroll restoration).

Out of the box, "scroll restoration" for all queries (including paginated and infinite queries) **Just Works‚Ñ¢Ô∏è** in BlazorQuery. The reason for this is that query results are cached and able to be retrieved synchronously when a query is rendered. As long as your queries are being cached long enough (the default time is 5 minutes with `gcTime`) and have not been garbage collected, scroll restoration will work out of the box all the time.

## How It Works

### The Problem with Traditional SPAs

In traditional SPAs without proper caching, when you navigate back to a page:

1. Component renders
2. Data fetch starts (loading state)
3. UI shows loading spinner or skeleton
4. **Layout shifts** as data loads
5. Scroll position is lost or incorrect

### BlazorQuery Solution

With BlazorQuery's caching:

1. Component renders
2. **Cached data available immediately**
3. UI renders with actual data (stable layout)
4. **Scroll position works correctly**
5. Background refetch happens (if data is stale)

## Basic Example

```csharp
public class PostsListPage : ComponentBase
{
    private readonly QueryClient _queryClient;
    private readonly NavigationManager _nav;
    private UseQuery<List<Post>>? _postsQuery;

    protected override async Task OnInitializedAsync()
    {
        // Create query - data may already be in cache
        _postsQuery = new UseQuery<List<Post>>(
            new QueryOptions<List<Post>>(
                queryKey: new("posts"),
                queryFn: async ctx => {
                    return await FetchPostsAsync();
                },
                staleTime: TimeSpan.FromMinutes(5) // Keep data fresh for 5 minutes
            ),
            _queryClient
        );

        await _postsQuery.ExecuteAsync();
    }

    private void OnPostClick(int postId)
    {
        // Navigate to detail page
        _nav.NavigateTo($"/posts/{postId}");
        
        // When user navigates back:
        // - Posts query data is still in cache
        // - List renders immediately with cached data
        // - Scroll position is preserved
        // - Background refetch happens if data is stale
    }
}
```

## Why It Works

### 1. **Synchronous Data Retrieval**

BlazorQuery can retrieve cached data synchronously:

```csharp
// When component re-renders after navigation back
protected override void OnInitialized()
{
    _postsQuery = new UseQuery<List<Post>>(
        new QueryOptions<List<Post>>(
            queryKey: new("posts"),
            queryFn: async ctx => await FetchPostsAsync()
        ),
        _queryClient
    );
    
    // If data is in cache, it's available immediately
    // No loading state -> stable layout -> scroll position works
}
```

### 2. **No Layout Shifts**

```csharp
@if (_postsQuery.IsLoading)
{
    <LoadingSpinner /> // Only shown on first visit
}
else if (_postsQuery.Data != null)
{
    @foreach (var post in _postsQuery.Data)
    {
        <PostCard Post="@post" />
    }
}

// On return navigation:
// - Data is in cache
// - IsLoading = false immediately
// - Full list renders immediately
// - No layout shift -> scroll position preserved
```

### 3. **Background Refetch**

```csharp
// Even with cached data displayed:
// - BlazorQuery checks staleness
// - Triggers background refetch if needed
// - Updates data without layout shift
// - Scroll position remains stable
```

## Complete Example: Blog App with Scroll Restoration

```csharp
public class BlogApp
{
    private readonly QueryClient _queryClient;
    private readonly NavigationManager _nav;

    // Posts List Page
    public class PostsListPage : ComponentBase
    {
        private UseQuery<List<Post>>? _postsQuery;

        protected override async Task OnInitializedAsync()
        {
            _postsQuery = new UseQuery<List<Post>>(
                new QueryOptions<List<Post>>(
                    queryKey: new("posts"),
                    queryFn: async ctx => {
                        Console.WriteLine("Fetching posts list...");
                        await Task.Delay(1000); // Simulate API call
                        return await FetchPostsListAsync();
                    },
                    staleTime: TimeSpan.FromMinutes(5)
                ),
                _queryClient
            );

            await _postsQuery.ExecuteAsync();
        }

        private void RenderPosts()
        {
            if (_postsQuery == null) return;

            if (_postsQuery.IsLoading)
            {
                Console.WriteLine("Loading posts...");
                // Only shown on first visit
            }
            else if (_postsQuery.Data != null)
            {
                Console.WriteLine($"Displaying {_postsQuery.Data.Count} posts");
                // Renders immediately with cached data on return navigation
                
                foreach (var post in _postsQuery.Data)
                {
                    Console.WriteLine($"  - {post.Title}");
                }
            }
        }

        private void OnPostClick(int postId)
        {
            // User scrolled to position 500px, clicked post #5
            Console.WriteLine("Navigating to post detail...");
            _nav.NavigateTo($"/posts/{postId}");
        }
    }

    // Post Detail Page
    public class PostDetailPage : ComponentBase
    {
        [Parameter] public int PostId { get; set; }
        private UseQuery<Post>? _postQuery;

        protected override async Task OnInitializedAsync()
        {
            _postQuery = new UseQuery<Post>(
                new QueryOptions<Post>(
                    queryKey: new("post", PostId),
                    queryFn: async ctx => {
                        Console.WriteLine($"Fetching post {PostId}...");
                        return await FetchPostDetailAsync(PostId);
                    },
                    staleTime: TimeSpan.FromMinutes(5)
                ),
                _queryClient
            );

            await _postQuery.ExecuteAsync();
        }

        private void OnBackClick()
        {
            Console.WriteLine("Navigating back to posts list...");
            _nav.NavigateTo("/posts");
            
            // What happens:
            // 1. Navigate back to posts list
            // 2. Posts list query finds data in cache
            // 3. List renders immediately with cached data
            // 4. Browser/framework restores scroll to 500px
            // 5. User sees same list at same position
            // 6. Background refetch updates data if stale
        }
    }
}
```

## Scroll Restoration Scenarios

### Scenario 1: Simple Navigation

```
User Journey:
1. Load posts list (fetch: 1s) ‚Üí scroll to position 500px
2. Click post #5 ‚Üí navigate to detail
3. Read post
4. Click back

With BlazorQuery:
- Posts list renders immediately with cached data
- Scroll position: 500px (restored by browser)
- Background refetch updates data if needed
- No layout shift, no loading spinner
```

### Scenario 2: Paginated Lists

```csharp
public class PaginatedPostsPage : ComponentBase
{
    private int _currentPage = 1;
    private UseQuery<PostsPage>? _pageQuery;

    private async Task LoadPageAsync(int page)
    {
        _currentPage = page;
        
        _pageQuery = new UseQuery<PostsPage>(
            new QueryOptions<PostsPage>(
                queryKey: new("posts", "page", page),
                queryFn: async ctx => await FetchPageAsync(page),
                placeholderDataFunc: (prevData, prevQuery) => prevData, // Keep previous page visible
                staleTime: TimeSpan.FromMinutes(5)
            ),
            _queryClient
        );

        await _pageQuery.ExecuteAsync();
    }

    private void OnPostClick(int postId)
    {
        // User on page 3, scrolled to position 800px
        _nav.NavigateTo($"/posts/{postId}");
        
        // On back navigation:
        // - Page 3 query data still in cache
        // - Renders immediately at page 3
        // - Scroll restored to 800px
        // - Perfect restoration
    }
}
```

### Scenario 3: Infinite Scroll

```csharp
public class InfinitePostsPage : ComponentBase
{
    private UseInfiniteQuery<PostsPage, int>? _infiniteQuery;

    protected override async Task OnInitializedAsync()
    {
        _infiniteQuery = new UseInfiniteQuery<PostsPage, int>(
            new InfiniteQueryOptions<PostsPage, int>(
                queryKey: new("posts", "infinite"),
                queryFn: async (ctx, pageParam) => await FetchPageAsync(pageParam),
                initialPageParam: 0,
                getNextPageParam: (lastPage, allPages, lastPageParam) => 
                    lastPage.NextCursor
            ),
            _queryClient
        );

        await _infiniteQuery.ExecuteAsync();
    }

    private async Task OnScrollEnd()
    {
        // User loaded 5 pages, scrolled to position 2000px
        if (_infiniteQuery.HasNextPage)
        {
            await _infiniteQuery.FetchNextPageAsync();
        }
    }

    private void OnPostClick(int postId)
    {
        _nav.NavigateTo($"/posts/{postId}");
        
        // On back navigation:
        // - All 5 pages still in cache
        // - All pages render immediately
        // - Scroll restored to 2000px
        // - User sees same content at same position
    }
}
```

## Integration with Blazor

### Blazor Server

```csharp
// In Blazor Server, scroll restoration is automatic
// BlazorQuery caching ensures data is available immediately

@page "/posts"
@inject QueryClient QueryClient
@inject NavigationManager Navigation

<div class="posts-list">
    @if (_query?.IsLoading == true)
    {
        <LoadingSpinner />
    }
    else if (_query?.Data != null)
    {
        @foreach (var post in _query.Data)
        {
            <PostCard Post="@post" OnClick="() => GoToPost(post.Id)" />
        }
    }
</div>

@code {
    private UseQuery<List<Post>>? _query;

    protected override async Task OnInitializedAsync()
    {
        _query = new UseQuery<List<Post>>(
            new QueryOptions<List<Post>>(
                queryKey: new("posts"),
                queryFn: async ctx => await Http.GetFromJsonAsync<List<Post>>("/api/posts")
                    ?? new List<Post>()
            ),
            QueryClient
        );

        await _query.ExecuteAsync();
    }

    private void GoToPost(int id)
    {
        Navigation.NavigateTo($"/posts/{id}");
    }
}
```

### Blazor WebAssembly

```csharp
// In Blazor WASM, scroll restoration may need manual handling
// But BlazorQuery caching still ensures data is available

@page "/posts"
@inject QueryClient QueryClient
@inject NavigationManager Navigation
@inject IJSRuntime JS

<div class="posts-list" @ref="_listElement">
    @* Same rendering logic *@
</div>

@code {
    private ElementReference _listElement;
    private UseQuery<List<Post>>? _query;

    protected override async Task OnInitializedAsync()
    {
        _query = new UseQuery<List<Post>>(
            new QueryOptions<List<Post>>(
                queryKey: new("posts"),
                queryFn: async ctx => await Http.GetFromJsonAsync<List<Post>>("/api/posts")
                    ?? new List<Post>()
            ),
            QueryClient
        );

        await _query.ExecuteAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && _query?.Data != null)
        {
            // Optional: Restore scroll position manually if needed
            var scrollPos = await GetStoredScrollPosition();
            if (scrollPos > 0)
            {
                await JS.InvokeVoidAsync("window.scrollTo", 0, scrollPos);
            }
        }
    }
}
```

## Best Practices

### 1. **Use Appropriate StaleTime**

```csharp
// ‚úÖ Good: Cache data long enough for navigation
new QueryOptions<List<Post>>(
    queryKey: new("posts"),
    queryFn: async ctx => await FetchPostsAsync(),
    staleTime: TimeSpan.FromMinutes(5) // Data stays fresh during session
)

// ‚ùå Bad: Too short staleTime
new QueryOptions<List<Post>>(
    queryKey: new("posts"),
    queryFn: async ctx => await FetchPostsAsync(),
    staleTime: TimeSpan.FromSeconds(10) // Data becomes stale too quickly
)
```

### 2. **Use PlaceholderData for Smooth Transitions**

```csharp
// ‚úÖ Good: Use placeholder for paginated lists
new QueryOptions<PostsPage>(
    queryKey: new("posts", page),
    queryFn: async ctx => await FetchPageAsync(page),
    placeholderDataFunc: (prevData, prevQuery) => prevData, // Keep previous data visible
    staleTime: TimeSpan.FromMinutes(5)
)

// Result: Smooth page transitions without layout shifts
```

### 3. **Prefetch Related Pages**

```csharp
// ‚úÖ Good: Prefetch next page for instant navigation
private async Task PrefetchNextPage(int currentPage)
{
    var nextPageQuery = new UseQuery<PostsPage>(
        new QueryOptions<PostsPage>(
            queryKey: new("posts", "page", currentPage + 1),
            queryFn: async ctx => await FetchPageAsync(currentPage + 1),
            staleTime: TimeSpan.FromMinutes(5)
        ),
        _queryClient
    );

    await nextPageQuery.ExecuteAsync();
}

// When user navigates to next page, data is already cached
```

### 4. **Handle List Updates Carefully**

```csharp
// ‚úÖ Good: Invalidate on mutations to keep data fresh
private async Task OnDeletePost(int postId)
{
    await DeletePostAsync(postId);
    
    // Invalidate to refetch list
    _queryClient.InvalidateQueries(new QueryFilters
    {
        QueryKey = new("posts")
    });
    
    // List refetches, scroll position preserved
    // (because data was in cache before refetch)
}
```

## Comparison with React Query

### React Query (TypeScript):
```typescript
// Scroll restoration works out of the box
function PostsList() {
  const { data, isLoading } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
    staleTime: 5 * 60 * 1000, // 5 minutes
  })

  return (
    <div>
      {isLoading ? (
        <Spinner />
      ) : (
        data.map(post => <PostCard key={post.id} post={post} />)
      )}
    </div>
  )
}

// With React Router
import { ScrollRestoration } from 'react-router-dom'

function App() {
  return (
    <>
      <Routes>...</Routes>
      <ScrollRestoration /> {/* Automatic scroll restoration */}
    </>
  )
}
```

### BlazorQuery (C#):
```csharp
// Scroll restoration works out of the box
@page "/posts"
@inject QueryClient QueryClient

<div class="posts-list">
    @if (_query?.IsLoading == true)
    {
        <Spinner />
    }
    else if (_query?.Data != null)
    {
        @foreach (var post in _query.Data)
        {
            <PostCard Post="@post" />
        }
    }
</div>

@code {
    private UseQuery<List<Post>>? _query;

    protected override async Task OnInitializedAsync()
    {
        _query = new UseQuery<List<Post>>(
            new QueryOptions<List<Post>>(
                queryKey: new("posts"),
                queryFn: async ctx => await FetchPostsAsync(),
                staleTime: TimeSpan.FromMinutes(5)
            ),
            QueryClient
        );

        await _query.ExecuteAsync();
    }
}

// Blazor handles scroll restoration automatically in most cases
```

---

## Summary

- ‚úÖ Scroll restoration **Just Works‚Ñ¢Ô∏è** with BlazorQuery
- ‚úÖ No special configuration needed
- ‚úÖ Works because of smart caching (5-minute default)
- ‚úÖ Data available synchronously on return navigation
- ‚úÖ No layout shifts = reliable scroll position
- ‚úÖ Background refetch updates data without disrupting scroll
- ‚úÖ Works with all query types (regular, paginated, infinite)
- ‚úÖ Use `placeholderData` for even smoother transitions
- ‚úÖ Browser/framework handles actual scroll restoration
- ‚úÖ BlazorQuery ensures stable layout for restoration to work

**The secret: Cached data + stable layout = perfect scroll restoration!** üìú‚ú®

