# Dependent Queries

Dependent (or serial) queries depend on previous ones to finish before they can execute. This creates a request chain where each query waits for the previous one to complete.

## Basic Dependent Query with `enabled`

To create a dependent query, use the `enabled` option to tell a query when it is ready to run:

```csharp
// Get the user
var userQuery = new UseQuery<User>(
    new QueryOptions<User>(
        queryKey: new("user", email),
        queryFn: async ctx => await GetUserByEmailAsync(email)
    ),
    queryClient
);

await userQuery.ExecuteAsync();
var userId = userQuery.Data?.Id;

// Then get the user's projects
var projectsQuery = new UseQuery<List<Project>>(
    new QueryOptions<List<Project>>(
        queryKey: new("projects", userId),
        queryFn: async ctx => await GetProjectsByUserAsync(userId!),
        enabled: !string.IsNullOrEmpty(userId) // Only execute when userId exists
    ),
    queryClient
);

await projectsQuery.ExecuteAsync();

// Access the results
if (projectsQuery.IsSuccess)
{
    var projects = projectsQuery.Data;
}
```

## Query State Transitions

The `projects` query will start in:

```csharp
Status: QueryStatus.Pending
IsPending: true
FetchStatus: FetchStatus.Idle
```

As soon as the `user` is available and you enable the query, it will transition to:

```csharp
Status: QueryStatus.Pending
IsPending: true
FetchStatus: FetchStatus.Fetching
```

Once we have the projects, it will go to:

```csharp
Status: QueryStatus.Success
IsPending: false
FetchStatus: FetchStatus.Idle
```

## Complete Example: User → Projects

```csharp
public class UserProjectsComponent : IDisposable
{
    private readonly QueryClient _queryClient;
    private UseQuery<User>? _userQuery;
    private UseQuery<List<Project>>? _projectsQuery;

    public UserProjectsComponent(QueryClient queryClient)
    {
        _queryClient = queryClient;
    }

    public async Task LoadUserAndProjectsAsync(string email)
    {
        // Step 1: Fetch user
        _userQuery = new UseQuery<User>(
            new QueryOptions<User>(
                queryKey: new("user", email),
                queryFn: async ctx => {
                    var (queryKey, signal) = ctx;
                    var userEmail = (string)queryKey[1]!;
                    return await _api.GetUserByEmailAsync(userEmail, signal);
                }
            ),
            _queryClient
        );

        await _userQuery.ExecuteAsync();

        if (!_userQuery.IsSuccess)
        {
            Console.WriteLine($"Failed to load user: {_userQuery.Error?.Message}");
            return;
        }

        var userId = _userQuery.Data!.Id;
        Console.WriteLine($"User loaded: {_userQuery.Data.Name}");

        // Step 2: Fetch projects (depends on userId)
        _projectsQuery = new UseQuery<List<Project>>(
            new QueryOptions<List<Project>>(
                queryKey: new("projects", userId),
                queryFn: async ctx => {
                    var (queryKey, signal) = ctx;
                    var uid = (string)queryKey[1]!;
                    return await _api.GetProjectsByUserAsync(uid, signal);
                },
                enabled: !string.IsNullOrEmpty(userId)
            ),
            _queryClient
        );

        await _projectsQuery.ExecuteAsync();

        if (_projectsQuery.IsSuccess)
        {
            Console.WriteLine($"Loaded {_projectsQuery.Data!.Count} projects");
        }
    }

    public void Dispose()
    {
        _userQuery?.Dispose();
        _projectsQuery?.Dispose();
    }
}
```

## Dependent Queries with UseQueries

Dynamic parallel queries with `UseQueries` can also depend on a previous query:

```csharp
// Step 1: Get the user IDs
var usersQuery = new UseQuery<List<string>>(
    new QueryOptions<List<string>>(
        queryKey: new("users"),
        queryFn: async ctx => {
            var users = await GetUsersDataAsync();
            return users.Select(u => u.Id).ToList();
        }
    ),
    queryClient
);

await usersQuery.ExecuteAsync();
var userIds = usersQuery.Data;

// Step 2: Get messages for each user (dependent)
var messagesQueries = new UseQueries<List<Message>>(queryClient);

var queries = userIds != null
    ? userIds.Select(id =>
        new QueryOptions<List<Message>>(
            queryKey: new("messages", id),
            queryFn: async ctx => {
                var (queryKey, signal) = ctx;
                var userId = (string)queryKey[1]!;
                return await GetMessagesByUserAsync(userId, signal);
            }
        ))
    : Enumerable.Empty<QueryOptions<List<Message>>>();

messagesQueries.SetQueries(queries);
await messagesQueries.ExecuteAllAsync();

// Access results
foreach (var query in messagesQueries.Queries)
{
    if (query.IsSuccess)
    {
        Console.WriteLine($"User has {query.Data!.Count} messages");
    }
}
```

**Note**: If `userIds` is null or empty, an empty array will be passed to `SetQueries()`, and no queries will execute.

## Dynamic Enable/Disable

You can dynamically change the `enabled` state:

```csharp
var options = new QueryOptions<Data>(
    queryKey: new("data"),
    queryFn: async ctx => await FetchDataAsync(),
    enabled: false // Initially disabled
);

var query = new UseQuery<Data>(options, queryClient);

// Later, when condition is met
if (someDependencyIsReady)
{
    options.Enabled = true;
    await query.ExecuteAsync();
}
```

## Reactive Pattern with Events

For a more reactive approach, you can use events to automatically trigger dependent queries:

```csharp
public class ReactiveLoadingComponent
{
    private readonly QueryClient _queryClient;
    private UseQuery<User>? _userQuery;
    private UseQuery<List<Project>>? _projectsQuery;

    public async Task LoadDataAsync(string email)
    {
        // Create user query
        _userQuery = new UseQuery<User>(
            new QueryOptions<User>(
                queryKey: new("user", email),
                queryFn: async ctx => await GetUserAsync(email)
            ),
            _queryClient
        );

        // Subscribe to user query changes
        _userQuery.OnChange += async () => {
            if (_userQuery.IsSuccess && _userQuery.Data != null)
            {
                await LoadProjectsAsync(_userQuery.Data.Id);
            }
        };

        // Start loading
        await _userQuery.ExecuteAsync();
    }

    private async Task LoadProjectsAsync(string userId)
    {
        _projectsQuery = new UseQuery<List<Project>>(
            new QueryOptions<List<Project>>(
                queryKey: new("projects", userId),
                queryFn: async ctx => await GetProjectsAsync(userId),
                enabled: true
            ),
            _queryClient
        );

        await _projectsQuery.ExecuteAsync();
    }
}
```

## Multiple Dependencies

You can chain multiple dependent queries:

```csharp
// Query 1: Get user
var userQuery = new UseQuery<User>(
    new QueryOptions<User>(
        queryKey: new("user", userId),
        queryFn: async ctx => await GetUserAsync(userId)
    ),
    queryClient
);

await userQuery.ExecuteAsync();
var organizationId = userQuery.Data?.OrganizationId;

// Query 2: Get organization (depends on user)
var orgQuery = new UseQuery<Organization>(
    new QueryOptions<Organization>(
        queryKey: new("organization", organizationId),
        queryFn: async ctx => await GetOrganizationAsync(organizationId!),
        enabled: !string.IsNullOrEmpty(organizationId)
    ),
    queryClient
);

await orgQuery.ExecuteAsync();
var teamId = orgQuery.Data?.DefaultTeamId;

// Query 3: Get team (depends on organization)
var teamQuery = new UseQuery<Team>(
    new QueryOptions<Team>(
        queryKey: new("team", teamId),
        queryFn: async ctx => await GetTeamAsync(teamId!),
        enabled: !string.IsNullOrEmpty(teamId)
    ),
    queryClient
);

await teamQuery.ExecuteAsync();

// Now you have user → organization → team
```

## Performance Note: Request Waterfalls

⚠️ **Important**: Dependent queries create [request waterfalls](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls), which can hurt performance.

If both queries take the same amount of time, doing them serially instead of in parallel always takes **twice as much time**. This is especially problematic on high-latency connections.

### Better Alternative: Restructure Backend APIs

Instead of:
```
Client → GetUserByEmail(email) → GetProjectsByUser(userId)
```

Consider creating a combined endpoint:
```
Client → GetProjectsByUserEmail(email)
```

This flattens the waterfall and improves performance significantly.

### When Dependent Queries Are Acceptable

Dependent queries are acceptable when:
- The dependency is truly required (can't be restructured)
- The queries are fast (low latency)
- The dependency is a local condition (not network data)
- User experience benefits from incremental loading

## Best Practices

### 1. **Use Meaningful Enabled Conditions**

```csharp
// Good: Clear dependency
enabled: !string.IsNullOrEmpty(userId)

// Good: Multiple conditions
enabled: userId != null && isUserActive

// Avoid: Complex logic that's hard to understand
enabled: (userId?.Length ?? 0) > 0 && !(userId?.StartsWith("temp") ?? true)
```

### 2. **Handle Loading States**

```csharp
if (userQuery.IsLoading)
{
    // Show user loading spinner
}
else if (userQuery.IsError)
{
    // Show error
}
else if (userQuery.IsSuccess && projectsQuery.IsLoading)
{
    // Show "user loaded, loading projects..."
}
```

### 3. **Cache Dependent Queries**

```csharp
var projectsQuery = new UseQuery<List<Project>>(
    new QueryOptions<List<Project>>(
        queryKey: new("projects", userId),
        queryFn: async ctx => await GetProjectsAsync(userId!),
        enabled: !string.IsNullOrEmpty(userId),
        staleTime: TimeSpan.FromMinutes(5) // Cache for 5 minutes
    ),
    queryClient
);
```

### 4. **Consider Optimistic Loading**

If you know the dependency will likely be available, you can start preparing:

```csharp
// Pre-create the dependent query (disabled)
var projectsQuery = new UseQuery<List<Project>>(
    new QueryOptions<List<Project>>(
        queryKey: new("projects", expectedUserId),
        queryFn: async ctx => await GetProjectsAsync(expectedUserId),
        enabled: false
    ),
    queryClient
);

// Later enable it
projectsOptions.Enabled = true;
await projectsQuery.ExecuteAsync();
```

## Comparison with React Query

### React Query (TypeScript):
```typescript
// Get the user
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
})

const userId = user?.id

// Then get the user's projects
const { data: projects } = useQuery({
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  enabled: !!userId, // Only run when userId exists
})
```

### BlazorQuery (C#):
```csharp
// Get the user
var userQuery = new UseQuery<User>(
    new QueryOptions<User>(
        queryKey: new("user", email),
        queryFn: async ctx => await GetUserByEmailAsync(email)
    ),
    queryClient
);

await userQuery.ExecuteAsync();
var userId = userQuery.Data?.Id;

// Then get the user's projects
var projectsQuery = new UseQuery<List<Project>>(
    new QueryOptions<List<Project>>(
        queryKey: new("projects", userId),
        queryFn: async ctx => await GetProjectsByUserAsync(userId!),
        enabled: !string.IsNullOrEmpty(userId)
    ),
    queryClient
);

await projectsQuery.ExecuteAsync();
```

**Key Differences**:
- BlazorQuery requires explicit `await query.ExecuteAsync()` calls
- React Query's hooks execute automatically when enabled
- BlazorQuery uses `!string.IsNullOrEmpty()` instead of `!!` operator

---

## Summary

- ✅ Use `enabled: false` to prevent query execution
- ✅ Set `enabled: true` when dependency is ready
- ✅ Query states: `Pending + Idle` → `Pending + Fetching` → `Success + Idle`
- ✅ Works with both `UseQuery` and `UseQueries`
- ✅ Can be dynamically enabled/disabled via `options.Enabled`
- ⚠️ Creates request waterfalls - consider backend restructuring
- ✅ Good for incremental loading UX

