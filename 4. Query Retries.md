

# Query Retries in BlazorQuery

When a query fails (the query function throws an exception), **BlazorQuery** will automatically retry 
the query if the number of consecutive retries has not exceeded the limit specified 
in the query options.

You can configure retries both on a global level (via `QueryClient` defaults) and 
on an individual query level (`QueryOptions<T>`).

### Retry Options

- Setting `Retry = 0` will disable retries.
- Setting `Retry = 3` will allow up to 3 total attempts (initial attempt + 2 retries).
- Custom retry logic can be provided via `RetryFunc: Func<int, Exception, bool>`, 
allowing conditional retries depending on the attempt number or exception.
- Retries apply only when an exception is thrown from the query function.
- Infinite retries are supported via `RetryInfinite = true`.

**Important:** Unlike React Query where `retry: 3` means 3 retries after the initial attempt 
(4 total attempts), BlazorQuery's `retry: 3` means a maximum of 3 total attempts. 
This is a design choice for simplicity.

```csharp
var query = new UseQuery<string>(
    new QueryOptions<string>(
        queryKey: new("todos", 1),
        queryFn: async ctx => await FetchTodoListPageAsync(),
        staleTime: TimeSpan.FromMinutes(5),
        networkMode: NetworkMode.Online,
        refetchOnReconnect: true,
        retry: 5 // Allow up to 5 total attempts (initial + 4 retries)
    ),
    queryClient
);
```

# Retry Delay

Retries in BlazorQuery are not immediate. A backoff delay is applied between retry 
attempts to reduce load and collisions.

By default, retries in **BlazorQuery** uses exponential backoff with jitter for retries:
- Initial delay is 1000ms.
- Delay doubles with each attempt (2^attempt * 1000ms).
- A random jitter of up to 300ms is added to prevent collisions.
- Maximum delay is capped by `MaxRetryDelay` (default: 30 seconds).
- Optionally, a custom retry delay function can be provided via 
`RetryDelayFunc: Func<int, TimeSpan>`.

```csharp
int delayMs;
if (_queryOptions.RetryDelayFunc != null)
{
    delayMs = (int)_queryOptions.RetryDelayFunc(attempt).TotalMilliseconds;
}
else
{
    double expDelay = Math.Pow(2, attempt) * 1000;
    double jitter = Random.Shared.NextDouble() * 300; // Thread-safe random
    delayMs = (int)Math.Min(expDelay + jitter, maxRetryDelay.TotalMilliseconds);
}

await Task.Delay(delayMs, cancellationToken);
```

# Custom Retry Delay

- Provide a custom delay function via `RetryDelayFunc: Func<int, TimeSpan>`.
- The function receives the current attempt index (0-based) and returns a `TimeSpan`
to wait before the next retry.

# Pause and Continue on Network Changes

If a query is running and you go offline while the fetch is still in progress,
BlazorQuery will pause the retry mechanism:

- **During active fetch**: The current fetch is cancelled and the query enters `Paused` state.
- **During retry delay**: The retry waits for the network to return before continuing.
- **Resume behavior**: Once back online, the query **continues** from where it left off
  (same attempt count) â€” this is NOT a refetch.
- **Cancellation**: If the query was cancelled while paused (e.g., component disposed),
  it will not continue when the network returns.

This behavior only applies to `NetworkMode.Online` and `NetworkMode.OfflineFirst`.
Queries with `NetworkMode.Always` do not pause and will fail immediately if the network is unavailable.

# Failure Tracking

BlazorQuery provides properties to track retry failures:

- **`FailureCount`**: The number of failed attempts so far (increments with each retry failure).
- **`FailureReason`**: The exception from the most recent retry attempt. This is available during
  retry attempts before the final `Error` is set. After the last retry fails, this becomes the `Error`.

```csharp
// During retries, FailureReason contains the current error
if (query.FailureCount > 0 && query.FailureReason != null)
{
    Console.WriteLine($"Attempt {query.FailureCount} failed: {query.FailureReason.Message}");
}

// After all retries exhausted, Error is set
if (query.Error != null)
{
    Console.WriteLine($"Query failed after {query.FailureCount} attempts: {query.Error.Message}");
}
```

# Background Retry Behavior

> **Not yet implemented**: TanStack Query supports `refetchIntervalInBackground` which pauses
> interval refetches when the browser tab is inactive. This is a browser-specific feature.
>
> In Blazor Server, the connection remains active regardless of tab visibility.
> In Blazor WebAssembly, you could implement this using the Page Visibility API via JS interop
> and conditionally pause/resume the query's refetch interval.
>
> If you need this feature, consider implementing a custom solution:
>
> ```csharp
> // Example: Manual control of refetch interval based on visibility
> @inject IJSRuntime JS
>
> @code {
>     private bool _isVisible = true;
>
>     protected override async Task OnAfterRenderAsync(bool firstRender)
>     {
>         if (firstRender)
>         {
>             // Set up visibility change listener via JS interop
>             await JS.InvokeVoidAsync("setupVisibilityListener",
>                 DotNetObjectReference.Create(this));
>         }
>     }
>
>     [JSInvokable]
>     public void OnVisibilityChange(bool isVisible)
>     {
>         _isVisible = isVisible;
>         // Manually pause/resume refetch or dispose/recreate query
>     }
> }
> ```