# Default Query Function

If you find yourself wishing that you could just share the same query function for your entire app and just use query keys to identify what it should fetch, you can do that by providing a **default query function** to BlazorQuery!

```csharp
// Define a default query function that will receive the query key
var defaultQueryFn = async (QueryFunctionContext ctx) => {
    var endpoint = ctx.QueryKey.Parts[0]?.ToString();
    var response = await httpClient.GetAsync(
        $"https://jsonplaceholder.typicode.com{endpoint}"
    );
    return await response.Content.ReadFromJsonAsync<object>();
};

// Provide the default query function to your app
var queryClient = new QueryClient
{
    DefaultQueryFn = defaultQueryFn
};

// All you have to do now is pass a key!
var postsQuery = new UseQuery<List<Post>>(
    new QueryOptions<List<Post>>(
        queryKey: new("/posts")
        // No queryFn needed!
    ),
    queryClient
);

// You can even add options without providing queryFn
var postQuery = new UseQuery<Post>(
    new QueryOptions<Post>(
        queryKey: new($"/posts/{postId}"),
        enabled: postId > 0
        // Still no queryFn needed!
    ),
    queryClient
);
```

If you ever want to override the default `queryFn`, you can just provide your own like you normally would.

## Complete Example

```csharp
public class ApiService
{
    private readonly HttpClient _httpClient;
    private readonly QueryClient _queryClient;

    public ApiService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        
        // Setup query client with default query function
        _queryClient = new QueryClient
        {
            DefaultQueryFn = DefaultQueryFunction
        };
    }

    private async Task<object> DefaultQueryFunction(QueryFunctionContext ctx)
    {
        // Extract endpoint from query key
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        
        if (string.IsNullOrEmpty(endpoint))
        {
            throw new ArgumentException("Query key must contain an endpoint");
        }

        // Make API request based on endpoint
        var response = await _httpClient.GetAsync(
            $"https://api.example.com{endpoint}",
            ctx.Signal
        );

        response.EnsureSuccessStatusCode();
        
        return await response.Content.ReadAsStringAsync();
    }

    // Now all queries can just use query keys!
    public async Task<UseQuery<List<Post>>> GetPostsQueryAsync()
    {
        var query = new UseQuery<List<Post>>(
            new QueryOptions<List<Post>>(
                queryKey: new("/posts"),
                staleTime: TimeSpan.FromMinutes(5)
            ),
            _queryClient
        );

        await query.ExecuteAsync();
        return query;
    }

    public async Task<UseQuery<Post>> GetPostQueryAsync(int postId)
    {
        var query = new UseQuery<Post>(
            new QueryOptions<Post>(
                queryKey: new($"/posts/{postId}"),
                enabled: postId > 0,
                staleTime: TimeSpan.FromMinutes(5)
            ),
            _queryClient
        );

        await query.ExecuteAsync();
        return query;
    }

    public async Task<UseQuery<List<Comment>>> GetCommentsQueryAsync(int postId)
    {
        var query = new UseQuery<List<Comment>>(
            new QueryOptions<List<Comment>>(
                queryKey: new($"/posts/{postId}/comments"),
                enabled: postId > 0
            ),
            _queryClient
        );

        await query.ExecuteAsync();
        return query;
    }
}
```

## Advanced Example: RESTful API Client

```csharp
public class RestApiClient
{
    private readonly HttpClient _httpClient;
    private readonly string _baseUrl;
    public readonly QueryClient QueryClient;

    public RestApiClient(HttpClient httpClient, string baseUrl)
    {
        _httpClient = httpClient;
        _baseUrl = baseUrl;
        
        QueryClient = new QueryClient
        {
            DefaultQueryFn = HandleRestRequest
        };
    }

    private async Task<object> HandleRestRequest(QueryFunctionContext ctx)
    {
        // Extract HTTP method and endpoint from query key
        var method = ctx.QueryKey.Parts[0]?.ToString();
        var endpoint = ctx.QueryKey.Parts[1]?.ToString();
        
        if (string.IsNullOrEmpty(method) || string.IsNullOrEmpty(endpoint))
        {
            throw new ArgumentException(
                "Query key must contain [method, endpoint]"
            );
        }

        var url = $"{_baseUrl}{endpoint}";

        HttpResponseMessage response = method.ToUpper() switch
        {
            "GET" => await _httpClient.GetAsync(url, ctx.Signal),
            "POST" => throw new NotSupportedException(
                "Use mutations for POST requests"
            ),
            _ => throw new ArgumentException($"Unsupported method: {method}")
        };

        response.EnsureSuccessStatusCode();
        return await response.Content.ReadAsStringAsync();
    }

    // Helper methods to create queries
    public UseQuery<T> CreateQuery<T>(string endpoint, QueryOptions<T>? options = null)
    {
        var defaultOptions = new QueryOptions<T>(
            queryKey: new("GET", endpoint),
            staleTime: options?.StaleTime ?? TimeSpan.FromMinutes(5)
        );

        return new UseQuery<T>(defaultOptions, QueryClient);
    }
}

// Usage
var client = new RestApiClient(httpClient, "https://api.example.com");

// All these queries use the default query function
var postsQuery = client.CreateQuery<List<Post>>("/posts");
await postsQuery.ExecuteAsync();

var userQuery = client.CreateQuery<User>("/users/123");
await userQuery.ExecuteAsync();

var commentsQuery = client.CreateQuery<List<Comment>>("/posts/1/comments");
await commentsQuery.ExecuteAsync();
```

## Type-Safe Example with Different Response Types

```csharp
public class TypedApiClient
{
    private readonly HttpClient _httpClient;
    public readonly QueryClient QueryClient;

    public TypedApiClient(HttpClient httpClient)
    {
        _httpClient = httpClient;
        
        QueryClient = new QueryClient
        {
            DefaultQueryFn = FetchData
        };
    }

    private async Task<object> FetchData(QueryFunctionContext ctx)
    {
        var resource = ctx.QueryKey.Parts[0]?.ToString();
        
        // Determine response type based on resource
        return resource switch
        {
            "posts" => await FetchPostsAsync(ctx),
            "users" => await FetchUsersAsync(ctx),
            "comments" => await FetchCommentsAsync(ctx),
            _ => throw new ArgumentException($"Unknown resource: {resource}")
        };
    }

    private async Task<object> FetchPostsAsync(QueryFunctionContext ctx)
    {
        if (ctx.QueryKey.Parts.Count > 1)
        {
            // Single post: /posts/{id}
            var id = ctx.QueryKey.Parts[1];
            var response = await _httpClient.GetAsync(
                $"https://api.example.com/posts/{id}",
                ctx.Signal
            );
            return await response.Content.ReadFromJsonAsync<Post>() 
                   ?? throw new Exception("Post not found");
        }
        else
        {
            // All posts: /posts
            var response = await _httpClient.GetAsync(
                "https://api.example.com/posts",
                ctx.Signal
            );
            return await response.Content.ReadFromJsonAsync<List<Post>>() 
                   ?? new List<Post>();
        }
    }

    private async Task<object> FetchUsersAsync(QueryFunctionContext ctx)
    {
        var id = ctx.QueryKey.Parts.Count > 1 ? ctx.QueryKey.Parts[1] : null;
        var endpoint = id != null 
            ? $"https://api.example.com/users/{id}"
            : "https://api.example.com/users";
        
        var response = await _httpClient.GetAsync(endpoint, ctx.Signal);
        
        if (id != null)
        {
            return await response.Content.ReadFromJsonAsync<User>() 
                   ?? throw new Exception("User not found");
        }
        else
        {
            return await response.Content.ReadFromJsonAsync<List<User>>() 
                   ?? new List<User>();
        }
    }

    private async Task<object> FetchCommentsAsync(QueryFunctionContext ctx)
    {
        var response = await _httpClient.GetAsync(
            "https://api.example.com/comments",
            ctx.Signal
        );
        return await response.Content.ReadFromJsonAsync<List<Comment>>() 
               ?? new List<Comment>();
    }
}

// Usage - Type-safe and clean
var apiClient = new TypedApiClient(httpClient);

// List of posts
var postsQuery = new UseQuery<List<Post>>(
    new QueryOptions<List<Post>>(queryKey: new("posts")),
    apiClient.QueryClient
);

// Single post
var postQuery = new UseQuery<Post>(
    new QueryOptions<Post>(queryKey: new("posts", 123)),
    apiClient.QueryClient
);

// List of users
var usersQuery = new UseQuery<List<User>>(
    new QueryOptions<List<User>>(queryKey: new("users")),
    apiClient.QueryClient
);

// Single user
var userQuery = new UseQuery<User>(
    new QueryOptions<User>(queryKey: new("users", 456)),
    apiClient.QueryClient
);
```

## Overriding Default Query Function

You can always override the default query function for specific queries:

```csharp
var queryClient = new QueryClient
{
    DefaultQueryFn = async ctx => {
        // Default implementation
        return await FetchFromApiAsync(ctx.QueryKey);
    }
};

// This query uses default query function
var query1 = new UseQuery<string>(
    new QueryOptions<string>(queryKey: new("data")),
    queryClient
);

// This query overrides with custom query function
var query2 = new UseQuery<string>(
    new QueryOptions<string>(
        queryKey: new("specialData"),
        queryFn: async ctx => {
            // Custom implementation for this specific query
            return await FetchFromSpecialSourceAsync();
        }
    ),
    queryClient
);
```

## Error Handling

If you don't provide a query function and haven't set a default, you'll get a helpful error:

```csharp
var queryClient = new QueryClient();
// No default query function set

try
{
    var query = new UseQuery<string>(
        new QueryOptions<string>(queryKey: new("data")),
        queryClient
    );
}
catch (InvalidOperationException ex)
{
    Console.WriteLine(ex.Message);
    // "No queryFn provided and no default query function configured.
    //  Either provide a queryFn in QueryOptions or set QueryClient.DefaultQueryFn."
}
```

## Type Safety

The default query function must return the correct type, or an exception will be thrown:

```csharp
var queryClient = new QueryClient
{
    DefaultQueryFn = async ctx => "String Data" // Returns string
};

var query = new UseQuery<int>( // Expects int
    new QueryOptions<int>(queryKey: new("data")),
    queryClient
);

try
{
    await query.ExecuteAsync();
}
catch (InvalidCastException ex)
{
    Console.WriteLine(ex.Message);
    // "Default query function returned String but expected Int32"
}
```

## Best Practices

### 1. **Use for Simple REST APIs**

```csharp
// âœ… Good: Simple REST API with consistent endpoints
var queryClient = new QueryClient
{
    DefaultQueryFn = async ctx => {
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        return await httpClient.GetFromJsonAsync<object>(
            $"https://api.example.com{endpoint}"
        );
    }
};

// Clean query creation
var query = new UseQuery<List<Post>>(
    new QueryOptions<List<Post>>(queryKey: new("/posts")),
    queryClient
);
```

### 2. **Override for Special Cases**

```csharp
// âœ… Good: Use default for most queries, override when needed
var normalQuery = new UseQuery<Data>(
    new QueryOptions<Data>(queryKey: new("/data")),
    queryClient
);

var specialQuery = new UseQuery<Data>(
    new QueryOptions<Data>(
        queryKey: new("/special"),
        queryFn: async ctx => await SpecialFetchAsync() // Override
    ),
    queryClient
);
```

### 3. **Include Query Key in Error Messages**

```csharp
// âœ… Good: Helpful error messages
DefaultQueryFn = async ctx => {
    try
    {
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        return await httpClient.GetFromJsonAsync<object>(endpoint);
    }
    catch (Exception ex)
    {
        throw new Exception(
            $"Failed to fetch {ctx.QueryKey}: {ex.Message}",
            ex
        );
    }
};
```

### 4. **Use CancellationToken**

```csharp
// âœ… Good: Support cancellation
DefaultQueryFn = async ctx => {
    var endpoint = ctx.QueryKey.Parts[0]?.ToString();
    return await httpClient.GetFromJsonAsync<object>(
        endpoint,
        ctx.Signal // Pass cancellation token
    );
};
```

## Comparison with React Query

### React Query (TypeScript):
```typescript
// Define default query function
const defaultQueryFn = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`
  )
  return data
}

// Provide to app
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})

// Use with just query key
const { data } = useQuery({ queryKey: ['/posts'] })

// Override when needed
const { data } = useQuery({
  queryKey: ['/special'],
  queryFn: () => fetchSpecial(),
})
```

### BlazorQuery (C#):
```csharp
// Define default query function
Func<QueryFunctionContext, Task<object>> defaultQueryFn = async ctx => {
    var endpoint = ctx.QueryKey.Parts[0]?.ToString();
    var response = await httpClient.GetAsync(
        $"https://jsonplaceholder.typicode.com{endpoint}"
    );
    return await response.Content.ReadFromJsonAsync<object>();
};

// Provide to app
var queryClient = new QueryClient
{
    DefaultQueryFn = defaultQueryFn
};

// Use with just query key
var query = new UseQuery<List<Post>>(
    new QueryOptions<List<Post>>(queryKey: new("/posts")),
    queryClient
);

// Override when needed
var specialQuery = new UseQuery<Data>(
    new QueryOptions<Data>(
        queryKey: new("/special"),
        queryFn: async ctx => await FetchSpecialAsync()
    ),
    queryClient
);
```

---

## Summary

- âœ… Set `QueryClient.DefaultQueryFn` for app-wide query function
- âœ… Query key determines what to fetch
- âœ… No need to provide `queryFn` in QueryOptions
- âœ… Override with custom `queryFn` when needed
- âœ… Type-safe: must return correct type
- âœ… Supports CancellationToken
- âœ… Helpful error messages if misconfigured
- âœ… Perfect for: REST APIs, consistent endpoints, microservices
- âœ… Cleaner code: focus on query keys, not fetch logic

**Use default query function to keep your queries simple and consistent!** ðŸŽ¯

