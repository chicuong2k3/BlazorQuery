# Default Query Function

If you find yourself wishing that you could just share the same query function for your entire app and just use query keys to identify what it should fetch, you can do that by providing **type-safe default query functions** to BlazorQuery!

## Type-Safe Design

Unlike JavaScript libraries, BlazorQuery uses a **type-safe approach** where you register default functions per type. This eliminates runtime casting and provides compile-time type safety.

```csharp
var queryClient = new QueryClient();

// Register type-specific default query functions
queryClient.SetDefaultQueryFn<List<Post>>(async ctx => {
    var endpoint = ctx.QueryKey.Parts[0]?.ToString();
    var response = await httpClient.GetAsync($"https://api.example.com{endpoint}");
    return await response.Content.ReadFromJsonAsync<List<Post>>() 
           ?? new List<Post>();
});

queryClient.SetDefaultQueryFn<Post>(async ctx => {
    var endpoint = ctx.QueryKey.Parts[0]?.ToString();
    var response = await httpClient.GetAsync($"https://api.example.com{endpoint}");
    return await response.Content.ReadFromJsonAsync<Post>() 
           ?? throw new Exception("Post not found");
});

// Now you can create queries without providing queryFn!
var postsQuery = new UseQuery<List<Post>>(
    new QueryOptions<List<Post>>(
        queryKey: new("/posts")
        // No queryFn needed - uses registered default for List<Post>
    ),
    queryClient
);

var postQuery = new UseQuery<Post>(
    new QueryOptions<Post>(
        queryKey: new($"/posts/{postId}"),
        enabled: postId > 0
        // No queryFn needed - uses registered default for Post
    ),
    queryClient
);
```

**Benefits of Type-Safe Approach:**
- âœ… **No runtime casting** - types are validated at compile time
- âœ… **Better performance** - no boxing/unboxing or type checking at runtime
- âœ… **Type-specific logic** - different types can have different default behaviors
- âœ… **Clearer error messages** - know exactly which type is missing a default
- âœ… **IntelliSense support** - full IDE support with type inference

If you ever want to override the default `queryFn`, you can just provide your own like you normally would.

## Complete Example

```csharp
public class ApiService
{
    private readonly HttpClient _httpClient;
    private readonly QueryClient _queryClient;

    public ApiService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        
        // Setup query client
        _queryClient = new QueryClient();
        
        // Register type-safe default query functions
        RegisterDefaultQueryFunctions();
    }

    private void RegisterDefaultQueryFunctions()
    {
        // Default function for List<Post>
        _queryClient.SetDefaultQueryFn<List<Post>>(async ctx => {
            var endpoint = ctx.QueryKey.Parts[0]?.ToString();
            if (string.IsNullOrEmpty(endpoint))
                throw new ArgumentException("Query key must contain an endpoint");

            var response = await _httpClient.GetAsync(
                $"https://api.example.com{endpoint}",
                ctx.Signal
            );
            response.EnsureSuccessStatusCode();
            
            return await response.Content.ReadFromJsonAsync<List<Post>>(
                cancellationToken: ctx.Signal
            ) ?? new List<Post>();
        });

        // Default function for single Post
        _queryClient.SetDefaultQueryFn<Post>(async ctx => {
            var endpoint = ctx.QueryKey.Parts[0]?.ToString();
            if (string.IsNullOrEmpty(endpoint))
                throw new ArgumentException("Query key must contain an endpoint");

            var response = await _httpClient.GetAsync(
                $"https://api.example.com{endpoint}",
                ctx.Signal
            );
            response.EnsureSuccessStatusCode();
            
            return await response.Content.ReadFromJsonAsync<Post>(
                cancellationToken: ctx.Signal
            ) ?? throw new Exception("Post not found");
        });

        // Default function for List<Comment>
        _queryClient.SetDefaultQueryFn<List<Comment>>(async ctx => {
            var endpoint = ctx.QueryKey.Parts[0]?.ToString();
            if (string.IsNullOrEmpty(endpoint))
                throw new ArgumentException("Query key must contain an endpoint");

            var response = await _httpClient.GetAsync(
                $"https://api.example.com{endpoint}",
                ctx.Signal
            );
            response.EnsureSuccessStatusCode();
            
            return await response.Content.ReadFromJsonAsync<List<Comment>>(
                cancellationToken: ctx.Signal
            ) ?? new List<Comment>();
        });
    }

    // Now all queries can just use query keys!
    public async Task<UseQuery<List<Post>>> GetPostsQueryAsync()
    {
        var query = new UseQuery<List<Post>>(
            new QueryOptions<List<Post>>(
                queryKey: new("/posts"),
                staleTime: TimeSpan.FromMinutes(5)
            ),
            _queryClient
        );

        await query.ExecuteAsync();
        return query;
    }

    public async Task<UseQuery<Post>> GetPostQueryAsync(int postId)
    {
        var query = new UseQuery<Post>(
            new QueryOptions<Post>(
                queryKey: new($"/posts/{postId}"),
                enabled: postId > 0,
                staleTime: TimeSpan.FromMinutes(5)
            ),
            _queryClient
        );

        await query.ExecuteAsync();
        return query;
    }

    public async Task<UseQuery<List<Comment>>> GetCommentsQueryAsync(int postId)
    {
        var query = new UseQuery<List<Comment>>(
            new QueryOptions<List<Comment>>(
                queryKey: new($"/posts/{postId}/comments"),
                enabled: postId > 0
            ),
            _queryClient
        );

        await query.ExecuteAsync();
        return query;
    }
}
```

## Advanced Example: Type-Safe REST API Client

```csharp
public class TypeSafeRestApiClient
{
    private readonly HttpClient _httpClient;
    private readonly string _baseUrl;
    public readonly QueryClient QueryClient;

    public TypeSafeRestApiClient(HttpClient httpClient, string baseUrl)
    {
        _httpClient = httpClient;
        _baseUrl = baseUrl;
        
        QueryClient = new QueryClient();
        RegisterAllDefaultFunctions();
    }

    private void RegisterAllDefaultFunctions()
    {
        // Register for common DTOs
        QueryClient.SetDefaultQueryFn<List<Post>>(ctx => FetchListAsync<Post>(ctx));
        QueryClient.SetDefaultQueryFn<Post>(ctx => FetchSingleAsync<Post>(ctx));
        QueryClient.SetDefaultQueryFn<List<User>>(ctx => FetchListAsync<User>(ctx));
        QueryClient.SetDefaultQueryFn<User>(ctx => FetchSingleAsync<User>(ctx));
        QueryClient.SetDefaultQueryFn<List<Comment>>(ctx => FetchListAsync<Comment>(ctx));
    }

    private async Task<List<T>> FetchListAsync<T>(QueryFunctionContext ctx)
    {
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        if (string.IsNullOrEmpty(endpoint))
            throw new ArgumentException("Endpoint required");

        var url = $"{_baseUrl}{endpoint}";
        var response = await _httpClient.GetAsync(url, ctx.Signal);
        response.EnsureSuccessStatusCode();

        return await response.Content.ReadFromJsonAsync<List<T>>(
            cancellationToken: ctx.Signal
        ) ?? new List<T>();
    }

    private async Task<T> FetchSingleAsync<T>(QueryFunctionContext ctx)
    {
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        if (string.IsNullOrEmpty(endpoint))
            throw new ArgumentException("Endpoint required");

        var url = $"{_baseUrl}{endpoint}";
        var response = await _httpClient.GetAsync(url, ctx.Signal);
        response.EnsureSuccessStatusCode();

        return await response.Content.ReadFromJsonAsync<T>(
            cancellationToken: ctx.Signal
        ) ?? throw new Exception($"{typeof(T).Name} not found");
    }

    // Helper method to create queries
    public UseQuery<T> CreateQuery<T>(
        string endpoint, 
        TimeSpan? staleTime = null)
    {
        return new UseQuery<T>(
            new QueryOptions<T>(
                queryKey: new(endpoint),
                staleTime: staleTime ?? TimeSpan.FromMinutes(5)
            ),
            QueryClient
        );
    }
}

// Usage
var client = new TypeSafeRestApiClient(httpClient, "https://api.example.com");

// All these queries use the registered type-safe defaults
var postsQuery = client.CreateQuery<List<Post>>("/posts");
await postsQuery.ExecuteAsync();

var userQuery = client.CreateQuery<User>("/users/123");
await userQuery.ExecuteAsync();

var commentsQuery = client.CreateQuery<List<Comment>>("/posts/1/comments");
await commentsQuery.ExecuteAsync();
```

## Type-Safe Example with Different Response Types

```csharp
public class TypedApiClient
{
    private readonly HttpClient _httpClient;
    public readonly QueryClient QueryClient;

    public TypedApiClient(HttpClient httpClient)
    {
        _httpClient = httpClient;
        
        QueryClient = new QueryClient
        {
            DefaultQueryFn = FetchData
        };
    }

    private async Task<object> FetchData(QueryFunctionContext ctx)
    {
        var resource = ctx.QueryKey.Parts[0]?.ToString();
        
        // Determine response type based on resource
        return resource switch
        {
            "posts" => await FetchPostsAsync(ctx),
            "users" => await FetchUsersAsync(ctx),
            "comments" => await FetchCommentsAsync(ctx),
            _ => throw new ArgumentException($"Unknown resource: {resource}")
        };
    }

    private async Task<object> FetchPostsAsync(QueryFunctionContext ctx)
    {
        if (ctx.QueryKey.Parts.Count > 1)
        {
            // Single post: /posts/{id}
            var id = ctx.QueryKey.Parts[1];
            var response = await _httpClient.GetAsync(
                $"https://api.example.com/posts/{id}",
                ctx.Signal
            );
            return await response.Content.ReadFromJsonAsync<Post>() 
                   ?? throw new Exception("Post not found");
        }
        else
        {
            // All posts: /posts
            var response = await _httpClient.GetAsync(
                "https://api.example.com/posts",
                ctx.Signal
            );
            return await response.Content.ReadFromJsonAsync<List<Post>>() 
                   ?? new List<Post>();
        }
    }

    private async Task<object> FetchUsersAsync(QueryFunctionContext ctx)
    {
        var id = ctx.QueryKey.Parts.Count > 1 ? ctx.QueryKey.Parts[1] : null;
        var endpoint = id != null 
            ? $"https://api.example.com/users/{id}"
            : "https://api.example.com/users";
        
        var response = await _httpClient.GetAsync(endpoint, ctx.Signal);
        
        if (id != null)
        {
            return await response.Content.ReadFromJsonAsync<User>() 
                   ?? throw new Exception("User not found");
        }
        else
        {
            return await response.Content.ReadFromJsonAsync<List<User>>() 
                   ?? new List<User>();
        }
    }

    private async Task<object> FetchCommentsAsync(QueryFunctionContext ctx)
    {
        var response = await _httpClient.GetAsync(
            "https://api.example.com/comments",
            ctx.Signal
        );
        return await response.Content.ReadFromJsonAsync<List<Comment>>() 
               ?? new List<Comment>();
    }
}

// Usage - Type-safe and clean
var apiClient = new TypedApiClient(httpClient);

// List of posts
var postsQuery = new UseQuery<List<Post>>(
    new QueryOptions<List<Post>>(queryKey: new("posts")),
    apiClient.QueryClient
);

// Single post
var postQuery = new UseQuery<Post>(
    new QueryOptions<Post>(queryKey: new("posts", 123)),
    apiClient.QueryClient
);

// List of users
var usersQuery = new UseQuery<List<User>>(
    new QueryOptions<List<User>>(queryKey: new("users")),
    apiClient.QueryClient
);

// Single user
var userQuery = new UseQuery<User>(
    new QueryOptions<User>(queryKey: new("users", 456)),
    apiClient.QueryClient
);
```

## Overriding Default Query Function

You can always override the default query function for specific queries:

```csharp
var queryClient = new QueryClient
{
    DefaultQueryFn = async ctx => {
        // Default implementation
        return await FetchFromApiAsync(ctx.QueryKey);
    }
};

// This query uses default query function
var query1 = new UseQuery<string>(
    new QueryOptions<string>(queryKey: new("data")),
    queryClient
);

// This query overrides with custom query function
var query2 = new UseQuery<string>(
    new QueryOptions<string>(
        queryKey: new("specialData"),
        queryFn: async ctx => {
            // Custom implementation for this specific query
            return await FetchFromSpecialSourceAsync();
        }
    ),
    queryClient
);
```

## Error Handling

If you don't provide a query function and haven't set a default, you'll get a helpful error:

```csharp
var queryClient = new QueryClient();
// No default query function set

try
{
    var query = new UseQuery<string>(
        new QueryOptions<string>(queryKey: new("data")),
        queryClient
    );
}
catch (InvalidOperationException ex)
{
    Console.WriteLine(ex.Message);
    // "No queryFn provided and no default query function configured.
    //  Either provide a queryFn in QueryOptions or set QueryClient.DefaultQueryFn."
}
```

## Type Safety

The default query function must return the correct type, or an exception will be thrown:

```csharp
var queryClient = new QueryClient
{
    DefaultQueryFn = async ctx => "String Data" // Returns string
};

var query = new UseQuery<int>( // Expects int
    new QueryOptions<int>(queryKey: new("data")),
    queryClient
);

try
{
    await query.ExecuteAsync();
}
catch (InvalidCastException ex)
{
    Console.WriteLine(ex.Message);
    // "Default query function returned String but expected Int32"
}
```

## Best Practices

### 1. **Use for Simple REST APIs**

```csharp
// âœ… Good: Simple REST API with consistent endpoints
var queryClient = new QueryClient
{
    DefaultQueryFn = async ctx => {
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        return await httpClient.GetFromJsonAsync<object>(
            $"https://api.example.com{endpoint}"
        );
    }
};

// Clean query creation
var query = new UseQuery<List<Post>>(
    new QueryOptions<List<Post>>(queryKey: new("/posts")),
    queryClient
);
```

### 2. **Override for Special Cases**

```csharp
// âœ… Good: Use default for most queries, override when needed
var normalQuery = new UseQuery<Data>(
    new QueryOptions<Data>(queryKey: new("/data")),
    queryClient
);

var specialQuery = new UseQuery<Data>(
    new QueryOptions<Data>(
        queryKey: new("/special"),
        queryFn: async ctx => await SpecialFetchAsync() // Override
    ),
    queryClient
);
```

### 3. **Include Query Key in Error Messages**

```csharp
// âœ… Good: Helpful error messages
DefaultQueryFn = async ctx => {
    try
    {
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        return await httpClient.GetFromJsonAsync<object>(endpoint);
    }
    catch (Exception ex)
    {
        throw new Exception(
            $"Failed to fetch {ctx.QueryKey}: {ex.Message}",
            ex
        );
    }
};
```

### 4. **Use CancellationToken**

```csharp
// âœ… Good: Support cancellation
DefaultQueryFn = async ctx => {
    var endpoint = ctx.QueryKey.Parts[0]?.ToString();
    return await httpClient.GetFromJsonAsync<object>(
        endpoint,
        ctx.Signal // Pass cancellation token
    );
};
```

## Comparison with React Query

### React Query (TypeScript):
```typescript
// Single object-based default function (runtime casting)
const defaultQueryFn = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`
  )
  return data // Returns 'any' - no type safety
}

// Provide to app
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})

// Use with just query key
const { data } = useQuery({ queryKey: ['/posts'] })
// data is 'any' - no type safety unless manually specified

// Override when needed
const { data } = useQuery({
  queryKey: ['/special'],
  queryFn: () => fetchSpecial(),
})
```

### BlazorQuery (C#):
```csharp
// Type-safe per-type default functions (compile-time checking)
var queryClient = new QueryClient();

// Register type-specific defaults
queryClient.SetDefaultQueryFn<List<Post>>(async ctx => {
    var endpoint = ctx.QueryKey.Parts[0]?.ToString();
    var response = await httpClient.GetAsync(
        $"https://jsonplaceholder.typicode.com{endpoint}"
    );
    return await response.Content.ReadFromJsonAsync<List<Post>>()
           ?? new List<Post>();
});

queryClient.SetDefaultQueryFn<Post>(async ctx => {
    var endpoint = ctx.QueryKey.Parts[0]?.ToString();
    var response = await httpClient.GetAsync(
        $"https://jsonplaceholder.typicode.com{endpoint}"
    );
    return await response.Content.ReadFromJsonAsync<Post>()
           ?? throw new Exception("Post not found");
});

// Use with just query key - FULL TYPE SAFETY
var postsQuery = new UseQuery<List<Post>>(
    new QueryOptions<List<Post>>(queryKey: new("/posts")),
    queryClient
);
// postsQuery.Data is List<Post> - compile-time type safety!

// Override when needed
var specialQuery = new UseQuery<Data>(
    new QueryOptions<Data>(
        queryKey: new("/special"),
        queryFn: async ctx => await FetchSpecialAsync()
    ),
    queryClient
);
```

### Key Differences:

| Feature | React Query | BlazorQuery |
|---------|-------------|-------------|
| **Type Safety** | Runtime (with manual typing) | Compile-time |
| **Default Function** | Single function for all | Per-type functions |
| **Runtime Casting** | Yes (implicit) | No casting needed |
| **Performance** | Runtime type checks | Compile-time checks |
| **Error Detection** | Runtime errors | Compile-time errors |
| **IntelliSense** | Limited | Full support |
| **Refactoring** | Risky | Safe |

**Why C#'s Approach is Better:**

1. **No Runtime Casting**: BlazorQuery's type-safe approach eliminates the need for runtime type checking and casting, improving performance.

2. **Compile-Time Safety**: Errors are caught during compilation, not at runtime when users are using your app.

3. **Better IntelliSense**: IDEs can provide accurate code completion and type hints.

4. **Explicit Type Handling**: Different types can have different default behaviors naturally.

5. **Performance**: No boxing/unboxing, no reflection for type checking.

---

## Summary

- âœ… **Type-Safe Design**: Register per-type default functions with `SetDefaultQueryFn<T>()`
- âœ… **No Runtime Casting**: Compile-time type safety eliminates runtime errors
- âœ… **Query key determines fetch**: Different endpoints, same type, same function
- âœ… **No repetitive queryFn definitions**: Set once per type, use everywhere
- âœ… **Override for special cases**: Provide custom queryFn when needed
- âœ… **Better than React Query**: Compile-time safety vs runtime checks
- âœ… **Supports CancellationToken**: Full async cancellation support
- âœ… **Perfect for REST APIs**: Consistent typed endpoints
- âœ… **C# Idiomatic**: Leverages C#'s strong type system

**Use type-safe default query functions for clean, type-safe queries!** ðŸŽ¯

