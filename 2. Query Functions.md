
# What is a Query Function?

A **Query Function** is any asynchronous method that fetches data. 
It must either return **a result** or **throw an exception** so that BlazorQuery can track **loading** 
and **error** states.

Query functions receive a `QueryFunctionContext` that provides:
- `QueryKey`: uniquely identifies the query.
- `Signal`: a `CancellationToken` that allows query cancellation.
- `Meta`: optional metadata for the query.
- `PageParam`: (For infinite queries only) the parameter for fetching the current 
page — see [Infinite Queries]() for details.

# Basic Usage

You can define a query function in several ways depending on your needs, including inline 
lambdas or extracted methods:

```csharp
// Simple query without parameters
var query = new UseQuery<List<string>>(
    new QueryOptions<List<string>>(
        queryKey: new("todos"),
        queryFn: async ctx => await FakeApi.GetTodosAsync()
    ),
    _queryClient
);

// Query with a parameter
var query = new UseQuery<string>(
    new QueryOptions<string>(
        queryKey: new("todo", todoId),
        queryFn: async ctx => await FakeApi.GetTodoByIdAsync(todoId)
    ),
    _queryClient
);

// Access query key values from context
var query = new UseQuery<string>(
    new QueryOptions<string>(
        queryKey: new("todo", todoId),
        queryFn: async ctx => {
            var id = (int)ctx.QueryKey[1]!;
            return await FakeApi.GetTodoByIdAsync(id);
        }
    ),
    _queryClient
);
```

```csharp
// Extracted query function for reusability
async Task<List<string>> FetchTodosAsync(QueryFunctionContext ctx)
{
    var status = (string?)ctx.QueryKey[1];
    return await FakeApi.GetTodosAsync(status);
}

var query = new UseQuery<List<string>>(
    new QueryOptions<List<string>>(
        queryKey: new("todos", "active"),
        queryFn: FetchTodosAsync
    ),
    _queryClient
);
```

# Handling Errors

BlazorQuery tracks query errors automatically. A query is considered failed if the function:
- Throws an exception (synchronously or asynchronously), or
- Returns a faulted `Task<T>`

```csharp
var query = new UseQuery<string>(
    new QueryOptions<string>(
        queryKey: new("todo", todoId),
        queryFn: async ctx => {
            if (somethingGoesWrong)
                throw new Exception("Something went wrong");

            if (somethingElseGoesWrong)
                return await Task.FromException<string>(new("Something else went wrong"));

            return await FetchTodoByIdAsync(todoId);
        }
    ),
    _queryClient
);

await query.ExecuteAsync();

if (query.IsError)
    Console.WriteLine(query.Error!.Message);
```

# Usage with HttpClient

Some HTTP clients (like `HttpClient`) do not automatically throw exceptions for non-success HTTP responses. 

In that case, you should check the response and throw manually:

```csharp
var query = new UseQuery<string>(
    new QueryOptions<string>(
        queryKey: new("todo", todoId),
        queryFn: async ctx => {
            var response = await http.GetAsync($"/api/todos/{todoId}");
            
            if (!response.IsSuccessStatusCode)
                throw new Exception($"Response was not ok: {response.StatusCode}");

            return await response.Content.ReadFromJsonAsync<string>()!;
        }
    ),
    _queryClient
);

await query.ExecuteAsync();
```

# Using Metadata

You can pass optional metadata via `QueryOptions.Meta` to provide additional context 
to your query function. This is useful for custom logic without cluttering the `QueryKey`:

```csharp
var query = new UseQuery<List<string>>(
    new QueryOptions<List<string>>(
        queryKey: new("todos"),
        queryFn: async ctx => {
            if (ctx.Meta?.TryGetValue("filter", out var filterValue) == true)
                return await FakeApi.GetFilteredTodosAsync((string)filterValue);
            
            return await FakeApi.GetTodosAsync();
        },
        meta: new Dictionary<string, object> { { "filter", "active" } }
    ),
    _queryClient
);
```

# Cancellation

You can pass a `CancellationToken` to `ExecuteAsync` to cancel a running query. The token 
is automatically passed to your query function via `QueryFunctionContext.Signal`, allowing you 
to propagate cancellation to underlying operations.

```csharp
var cts = new CancellationTokenSource();
await query.ExecuteAsync(cts.Token);

// Later, cancel if needed
cts.Cancel();
```

**Propagating the signal to HttpClient:**

```csharp
var query = new UseQuery<string>(
    new QueryOptions<string>(
        queryKey: new("todo", 1),
        queryFn: async ctx => {
            var response = await http.GetAsync("/api/todo/1", ctx.Signal);
            return await response.Content.ReadAsStringAsync();
        }
    ),
    _queryClient
);
```