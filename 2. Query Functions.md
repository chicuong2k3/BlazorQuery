
# What is a Query Function?

A **Query Function** is any asynchronous method that fetches data. 
It must either return **a result** or **throw an exception** so that BlazorQuery can track **loading** 
and **error** states.

Query functions receive a `QueryFunctionContext` that provides:
- `QueryKey`: uniquely identifies the query.
- `Signal`: a `CancellationToken` that allows query cancellation.
- `Meta`: optional metadata for the query.
- `PageParam`: (For infinite queries only) the parameter for fetching the current 
page — see [Infinite Queries]() for details.

# Basic Usage

You can define a query function in several ways depending on your needs, including inline 
lambdas or extracted methods:

```csharp
// Simple query without parameters (inline lambda)
var query = new UseQuery<List<string>>(new QueryOptions<List<string>>(
    queryKey: new QueryKey("todos"),
    queryFn: async ctx => await FakeApi.GetTodosAsync()
), _queryClient);

// Query with a single parameter (inline lambda)
var query = new UseQuery<string>(new QueryOptions<string>(
    queryKey: new QueryKey("todos"),
    queryFn: async ctx => await FakeApi.GetTodoByIdAsync(1)
), _queryClient);

// Using QueryFunctionContext to access query key values (inline lambda)
var query = new UseQuery<string>(new QueryOptions<string>(
    queryKey: new QueryKey("todos", -1),
    queryFn: async ctx => await FakeApi.GetTodoByIdAsync((int)ctx.QueryKey[1]!)
), _queryClient);
```

```csharp
// Extracted query function method for reusability
async Task<List<string>> FetchTodosAsync(QueryFunctionContext ctx)
{
    // Access context properties as needed
    var status = (string?)ctx.QueryKey[1];
    return await FakeApi.GetTodosAsync(status);
}

var query = new UseQuery<List<string>>(new QueryOptions<List<string>>(
    queryKey: new QueryKey("todos", "active"),
    queryFn: FetchTodosAsync
), _queryClient);
```

# Handling Errors

BlazorQuery tracks query errors automatically. A query is considered failed if the function:
- Throws an exception (synchronously or asynchronously), or
- Returns a faulted `Task<T>`

```csharp
int todoId = -1;
var query = new UseQuery<string>(new QueryOptions<string>(
    queryKey: new QueryKey("todo", todoId),
    queryFn: async ctx => {
        if (somethingGoesWrong)
            throw new Exception("Something went wrong");

        if (somethingElseGoesWrong)
            return await Task.FromException<string>(new Exception("Something else went wrong"));

         return await FetchTodoByIdAsync(todoId);
    }
), client: _queryClient);

await query.ExecuteAsync();

if (query.IsError)
    Console.WriteLine(query.Error!.Message);
```

# Usage with HttpClient

Some HTTP clients (like `HttpClient`) do not automatically throw exceptions for non-success HTTP responses. 

In that case, you should check the response and throw manually:

```csharp
int todoId = -1;
var query = new UseQuery<string>(new QueryOptions<string>(
    queryKey: new QueryKey("todo", todoId),
    queryFn: async ctx => {
        var response = await http.GetAsync($"/api/todos/{todoId}");
        if (!response.IsSuccessStatusCode)
            throw new Exception($"Response was not ok: {response.StatusCode}");

        return await response.Content.ReadFromJsonAsync<string>()!;
    }
), client: _queryClient);

await query.ExecuteAsync();
```

# Using Metadata

You can pass optional metadata via `QueryOptions.Meta` to provide additional context 
to your query function. This is useful for custom logic without cluttering the `QueryKey`:

```csharp
var query = new UseQuery<List<string>>(new QueryOptions<List<string>>(
    queryKey: new QueryKey("todos"),
    queryFn: async ctx => {
        if (ctx.Meta != null && ctx.Meta.TryGetValue("filter", out var filterValue))
        {
            return await FakeApi.GetFilteredTodosAsync((string)filterValue);
        }
        return await FakeApi.GetTodosAsync();
    },
    meta: new Dictionary<string, object> { { "filter", "active" } }
), _queryClient);
```

# Cancellation

You can pass a `CancellationToken` to `ExecuteAsync` to cancel a running query. The token 
is automatically passed to your query function via `QueryFunctionContext.Signal`, allowing you 
to propagate cancellation to underlying operations.

```csharp
var cts = new CancellationTokenSource();
await query.ExecuteAsync(cts.Token);

// Later, cancel if needed
cts.Cancel();

// Propagating the signal
var query = new UseQuery<string>(new QueryOptions<string>(
    queryKey: new QueryKey("todo", 1),
    queryFn: async ctx => {
        var request = new HttpRequestMessage(HttpMethod.Get, "/api/todo/1");
        var response = await http.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, ctx.Signal);
        return await response.Content.ReadAsStringAsync();
    }
), _queryClient);
```