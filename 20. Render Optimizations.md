# Render Optimizations

BlazorQuery applies several optimizations to ensure that your components only re-render when they actually need to. While some optimizations differ from React Query due to C#/.NET architecture, the core principles remain the same.

## Structural Sharing

BlazorQuery uses a technique called "structural sharing" to ensure that as many references as possible will be kept intact between re-renders. If data is fetched over the network, usually, you'll get a completely new reference by JSON parsing the response. However, BlazorQuery will keep the original reference if _nothing_ changed in the data.

> **Note**: This optimization works best with immutable data types. For reference types, BlazorQuery uses reference equality checks to determine if data has changed.

### Referential Identity

The `UseQuery<T>`, `UseInfiniteQuery<T>`, and array returned from `UseQueries` objects themselves are **not referentially stable** - they are new instances. However, the `Data` properties returned from these will be as stable as possible through reference comparison.

```csharp
public class TodosComponent : ComponentBase
{
    private UseQuery<List<Todo>>? _todosQuery;

    protected override async Task OnInitializedAsync()
    {
        _todosQuery = new UseQuery<List<Todo>>(
            new QueryOptions<List<Todo>>(
                queryKey: new("todos"),
                queryFn: async ctx => await FetchTodosAsync()
            ),
            _queryClient
        );

        // Subscribe to changes
        _todosQuery.OnChange += StateHasChanged;

        await _todosQuery.ExecuteAsync();
    }

    // OnChange only fires when data/status actually changes
    // Not on every internal state update
}
```

## Event-Based Re-rendering

BlazorQuery uses an event-based system (`OnChange` event) to notify components when query state changes. Components only re-render when they explicitly subscribe to these events:

```csharp
public class OptimizedComponent : ComponentBase
{
    private UseQuery<List<Todo>>? _todosQuery;

    protected override async Task OnInitializedAsync()
    {
        _todosQuery = new UseQuery<List<Todo>>(
            new QueryOptions<List<Todo>>(
                queryKey: new("todos"),
                queryFn: async ctx => await FetchTodosAsync()
            ),
            _queryClient
        );

        // Only re-render when OnChange fires
        _todosQuery.OnChange += StateHasChanged;

        await _todosQuery.ExecuteAsync();
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing && _todosQuery != null)
        {
            // Unsubscribe to prevent memory leaks
            _todosQuery.OnChange -= StateHasChanged;
            _todosQuery.Dispose();
        }
        base.Dispose(disposing);
    }
}
```

## Smart OnChange Firing

BlazorQuery's `UseQuery` only fires `OnChange` when meaningful state changes occur:

```csharp
// Inside UseQuery<T>
public T? Data 
{ 
    get => _data;
    private set
    {
        // Only notify if data actually changed
        if (Equals(_data, value))
            return;
        _data = value;
        Notify(); // Fires OnChange
    }
}

public Exception? Error 
{
    get => _error;
    private set
    {
        // Only notify if error changed
        if (_error?.Equals(value) ?? value == null)
            return;
        _error = value;
        Notify();
    }
}
```

This means components won't re-render for:
- Internal state updates that don't affect public properties
- Reference updates where data is actually the same
- Intermediate fetch states that don't change exposed state

## Select for Data Transformation

You can transform query data without causing unnecessary re-renders by using computed properties or methods:

```csharp
public class TodosComponent : ComponentBase
{
    private UseQuery<List<Todo>>? _todosQuery;

    // Computed property - only recalculates when Data changes
    private int TodoCount => _todosQuery?.Data?.Count ?? 0;

    // Filtered todos - only recalculates when Data changes
    private List<Todo> CompletedTodos => 
        _todosQuery?.Data?.Where(t => t.Completed).ToList() 
        ?? new List<Todo>();

    // Custom selector method
    private List<Todo> SelectTodosByStatus(bool completed) =>
        _todosQuery?.Data?.Where(t => t.Completed == completed).ToList()
        ?? new List<Todo>();

    protected override async Task OnInitializedAsync()
    {
        _todosQuery = new UseQuery<List<Todo>>(
            new QueryOptions<List<Todo>>(
                queryKey: new("todos"),
                queryFn: async ctx => await FetchTodosAsync()
            ),
            _queryClient
        );

        _todosQuery.OnChange += StateHasChanged;
        await _todosQuery.ExecuteAsync();
    }

    // Component only re-renders when Data changes
    // Selectors are just computed on-demand
}
```

## Selective Re-rendering with Conditions

You can conditionally trigger re-renders based on specific state changes:

```csharp
public class ConditionalRenderComponent : ComponentBase
{
    private UseQuery<List<Todo>>? _todosQuery;
    private int _previousCount = 0;

    protected override async Task OnInitializedAsync()
    {
        _todosQuery = new UseQuery<List<Todo>>(
            new QueryOptions<List<Todo>>(
                queryKey: new("todos"),
                queryFn: async ctx => await FetchTodosAsync()
            ),
            _queryClient
        );

        // Custom re-render logic
        _todosQuery.OnChange += HandleQueryChange;

        await _todosQuery.ExecuteAsync();
    }

    private void HandleQueryChange()
    {
        var currentCount = _todosQuery?.Data?.Count ?? 0;

        // Only re-render if count changed (not if individual todo changed)
        if (currentCount != _previousCount)
        {
            _previousCount = currentCount;
            StateHasChanged();
        }
    }
}
```

## Memoization Patterns

In C#, you can use lazy evaluation and caching for expensive transformations:

```csharp
public class MemoizedComponent : ComponentBase
{
    private UseQuery<List<Todo>>? _todosQuery;
    private List<Todo>? _cachedCompletedTodos;
    private List<Todo>? _lastDataReference;

    private List<Todo> CompletedTodos
    {
        get
        {
            // Return cached value if data hasn't changed
            if (_cachedCompletedTodos != null && 
                ReferenceEquals(_lastDataReference, _todosQuery?.Data))
            {
                return _cachedCompletedTodos;
            }

            // Recalculate and cache
            _lastDataReference = _todosQuery?.Data;
            _cachedCompletedTodos = _todosQuery?.Data?
                .Where(t => t.Completed)
                .ToList() ?? new List<Todo>();

            return _cachedCompletedTodos;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        _todosQuery = new UseQuery<List<Todo>>(
            new QueryOptions<List<Todo>>(
                queryKey: new("todos"),
                queryFn: async ctx => await FetchTodosAsync()
            ),
            _queryClient
        );

        _todosQuery.OnChange += StateHasChanged;
        await _todosQuery.ExecuteAsync();
    }
}
```

## Complete Example: Optimized Todo List

```csharp
public class OptimizedTodoList : ComponentBase
{
    [Inject] private QueryClient QueryClient { get; set; } = null!;
    [Inject] private HttpClient Http { get; set; } = null!;

    private UseQuery<List<Todo>>? _todosQuery;
    private string _filter = "all"; // "all", "active", "completed"

    // Memoized selectors
    private List<Todo>? _cachedFilteredTodos;
    private string? _lastFilterApplied;

    private List<Todo> FilteredTodos
    {
        get
        {
            // Return cached if filter and data haven't changed
            if (_cachedFilteredTodos != null && 
                _lastFilterApplied == _filter &&
                _todosQuery?.Data != null)
            {
                return _cachedFilteredTodos;
            }

            // Recalculate
            _lastFilterApplied = _filter;
            _cachedFilteredTodos = _filter switch
            {
                "active" => _todosQuery?.Data?.Where(t => !t.Completed).ToList(),
                "completed" => _todosQuery?.Data?.Where(t => t.Completed).ToList(),
                _ => _todosQuery?.Data
            } ?? new List<Todo>();

            return _cachedFilteredTodos;
        }
    }

    // Computed properties - only recalculate on render
    private int TotalCount => _todosQuery?.Data?.Count ?? 0;
    private int ActiveCount => _todosQuery?.Data?.Count(t => !t.Completed) ?? 0;
    private int CompletedCount => _todosQuery?.Data?.Count(t => t.Completed) ?? 0;

    protected override async Task OnInitializedAsync()
    {
        _todosQuery = new UseQuery<List<Todo>>(
            new QueryOptions<List<Todo>>(
                queryKey: new("todos"),
                queryFn: async ctx => {
                    var response = await Http.GetAsync("/api/todos", ctx.Signal);
                    return await response.Content
                        .ReadFromJsonAsync<List<Todo>>(cancellationToken: ctx.Signal)
                        ?? new List<Todo>();
                },
                staleTime: TimeSpan.FromMinutes(5)
            ),
            QueryClient
        );

        _todosQuery.OnChange += StateHasChanged;
        await _todosQuery.ExecuteAsync();
    }

    private void SetFilter(string filter)
    {
        if (_filter != filter)
        {
            _filter = filter;
            _cachedFilteredTodos = null; // Invalidate cache
            StateHasChanged();
        }
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing && _todosQuery != null)
        {
            _todosQuery.OnChange -= StateHasChanged;
            _todosQuery.Dispose();
        }
        base.Dispose(disposing);
    }
}

// Razor markup
@if (_todosQuery?.IsLoading == true)
{
    <p>Loading...</p>
}
else if (_todosQuery?.IsError == true)
{
    <p>Error: @_todosQuery.Error?.Message</p>
}
else
{
    <div class="todo-filters">
        <button @onclick="() => SetFilter(\"all\")">All (@TotalCount)</button>
        <button @onclick="() => SetFilter(\"active\")">Active (@ActiveCount)</button>
        <button @onclick="() => SetFilter(\"completed\")">Completed (@CompletedCount)</button>
    </div>

    <ul class="todo-list">
        @foreach (var todo in FilteredTodos)
        {
            <li>@todo.Title - @(todo.Completed ? "✓" : "○")</li>
        }
    </ul>
}
```

## Comparison with React Query

### React Query (TypeScript):
```typescript
// Tracked properties - auto-optimized
const { data, isLoading } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
})

// Select for transformation
const { data: todoCount } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  select: (data) => data.length,
})

// Memoized selector
const selectTodoCount = useCallback(
  (data) => data.length,
  []
)

const { data } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  select: selectTodoCount,
})
```

### BlazorQuery (C#):
```csharp
// Event-based re-rendering - explicit subscription
var query = new UseQuery<List<Todo>>(
    new QueryOptions<List<Todo>>(
        queryKey: new("todos"),
        queryFn: async ctx => await FetchTodosAsync()
    ),
    queryClient
);

query.OnChange += StateHasChanged; // Explicit subscription

// Computed property for transformation
private int TodoCount => query?.Data?.Count ?? 0;

// Memoized selector with caching
private List<Todo>? _cachedResult;
private List<Todo>? _lastDataRef;

private List<Todo> FilteredTodos
{
    get
    {
        if (_cachedResult != null && 
            ReferenceEquals(_lastDataRef, query?.Data))
            return _cachedResult;

        _lastDataRef = query?.Data;
        _cachedResult = query?.Data?
            .Where(t => t.Completed)
            .ToList() ?? new List<Todo>();

        return _cachedResult;
    }
}
```

## Best Practices

### 1. **Subscribe Only When Needed**

```csharp
// ✅ Good: Only subscribe if component needs updates
protected override async Task OnInitializedAsync()
{
    _todosQuery = new UseQuery<List<Todo>>(...);
    
    if (_needsAutoUpdate)
    {
        _todosQuery.OnChange += StateHasChanged;
    }
    
    await _todosQuery.ExecuteAsync();
}

// ❌ Bad: Always subscribing even if not needed
_todosQuery.OnChange += StateHasChanged; // Always re-renders
```

### 2. **Unsubscribe to Prevent Memory Leaks**

```csharp
// ✅ Good: Clean up subscriptions
protected override void Dispose(bool disposing)
{
    if (disposing && _todosQuery != null)
    {
        _todosQuery.OnChange -= StateHasChanged;
        _todosQuery.Dispose();
    }
    base.Dispose(disposing);
}

// ❌ Bad: Forget to unsubscribe
// Memory leak - component held in memory by event
```

### 3. **Use Computed Properties for Transformations**

```csharp
// ✅ Good: Computed property - calculated on demand
private int ActiveTodoCount => 
    _todosQuery?.Data?.Count(t => !t.Completed) ?? 0;

// ❌ Bad: Store transformed data separately
private int _activeTodoCount; // Needs manual sync
```

### 4. **Cache Expensive Transformations**

```csharp
// ✅ Good: Cache expensive operations
private List<TodoGroup>? _cachedGroups;
private List<Todo>? _lastDataRef;

private List<TodoGroup> GroupedTodos
{
    get
    {
        if (_cachedGroups != null && 
            ReferenceEquals(_lastDataRef, _todosQuery?.Data))
            return _cachedGroups;

        _lastDataRef = _todosQuery?.Data;
        _cachedGroups = _todosQuery?.Data?
            .GroupBy(t => t.Category)
            .Select(g => new TodoGroup { ... })
            .ToList() ?? new List<TodoGroup>();

        return _cachedGroups;
    }
}

// ❌ Bad: Recalculate every time
private List<TodoGroup> GroupedTodos => 
    _todosQuery?.Data?.GroupBy(...).ToList() ?? new(); // Expensive!
```

### 5. **Conditional Re-rendering**

```csharp
// ✅ Good: Only re-render on meaningful changes
private int _lastCount = 0;

private void HandleQueryChange()
{
    var currentCount = _todosQuery?.Data?.Count ?? 0;
    
    if (currentCount != _lastCount)
    {
        _lastCount = currentCount;
        StateHasChanged();
    }
}

// ❌ Bad: Always re-render
_todosQuery.OnChange += StateHasChanged; // Re-renders for everything
```

## Performance Tips

### 1. **Reference Equality Checks**

BlazorQuery uses reference equality (`ReferenceEquals`) for objects:

```csharp
// If data reference hasn't changed, no OnChange is fired
public T? Data 
{ 
    get => _data;
    private set
    {
        if (Equals(_data, value)) // Reference equality for objects
            return;
        _data = value;
        Notify();
    }
}
```

### 2. **Immutable Data Structures**

For best performance, use immutable data:

```csharp
// ✅ Good: Immutable record
public record Todo(int Id, string Title, bool Completed);

// When updating, create new list
var updatedTodos = existingTodos
    .Select(t => t.Id == updatedId 
        ? t with { Completed = true } 
        : t)
    .ToList();

// This creates a new reference, triggering OnChange
```

### 3. **Avoid Over-Subscribing**

```csharp
// ✅ Good: One query, one subscription
_todosQuery.OnChange += StateHasChanged;

// ❌ Bad: Multiple subscriptions
_todosQuery.OnChange += StateHasChanged;
_todosQuery.OnChange += LogChange;
_todosQuery.OnChange += UpdateMetrics;
// Each fires on every change!
```

---

## Summary

- ✅ **Structural Sharing**: Reference stability for unchanged data
- ✅ **Event-Based**: `OnChange` event for explicit re-rendering control
- ✅ **Smart Notifications**: Only fires when meaningful state changes
- ✅ **Computed Properties**: Transform data without re-rendering overhead
- ✅ **Memoization**: Cache expensive transformations with reference checks
- ✅ **Selective Re-rendering**: Conditional `StateHasChanged` calls
- ✅ **Memory Management**: Unsubscribe events in Dispose
- ✅ **Immutable Data**: Best performance with immutable structures

**BlazorQuery optimizations ensure your Blazor apps stay fast and responsive!** ⚡

