# Security Best Practices

BlazorQuery provides type safety and audit logging, but **security is a shared responsibility**. This guide covers essential security practices when using BlazorQuery in production.

## Understanding Security Boundaries

### What BlazorQuery Validates

‚úÖ **Type Safety**: Ensures query results match expected types  
‚úÖ **Null Safety**: Validates non-nullable value types  
‚úÖ **Audit Logging**: Tracks all query operations  

### What YOU Must Validate

‚ö†Ô∏è **Data Content**: Validate all data from external sources  
‚ö†Ô∏è **Authorization**: Check user permissions before data access  
‚ö†Ô∏è **Input Sanitization**: Clean all user inputs to prevent injection  
‚ö†Ô∏è **Business Rules**: Enforce your application's security policies  

## Critical Security Principles

### 1. Never Trust External Data

**‚ùå DANGEROUS**:
```csharp
var queryClient = new QueryClient
{
    DefaultQueryFn = async ctx => {
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        // Directly using user input - DANGEROUS!
        return await httpClient.GetFromJsonAsync<object>(endpoint);
    }
};
```

**‚úÖ SECURE**:
```csharp
var queryClient = new QueryClient
{
    DefaultQueryFn = async ctx => {
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        
        // 1. Validate endpoint against whitelist
        if (!IsWhitelistedEndpoint(endpoint))
        {
            throw new SecurityException($"Endpoint not allowed: {endpoint}");
        }
        
        // 2. Sanitize parameters
        var sanitized = SanitizeEndpoint(endpoint);
        
        // 3. Check authorization
        if (!await IsAuthorizedAsync(GetCurrentUser(), sanitized))
        {
            throw new UnauthorizedAccessException();
        }
        
        // 4. Fetch with timeout
        using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
        var response = await httpClient.GetAsync(sanitized, cts.Token);
        
        // 5. Validate response
        var data = await response.Content.ReadFromJsonAsync<object>();
        if (!IsValidData(data))
        {
            throw new DataValidationException("Invalid response data");
        }
        
        return data;
    }
};
```

### 2. Implement Endpoint Whitelisting

**‚úÖ RECOMMENDED APPROACH**:
```csharp
public class SecureEndpointValidator
{
    private readonly HashSet<string> _allowedEndpoints = new()
    {
        "/api/todos",
        "/api/todos/{id}",
        "/api/users",
        "/api/users/{id}",
        "/api/posts",
        "/api/posts/{id}"
    };
    
    private readonly Dictionary<string, Regex> _allowedPatterns = new()
    {
        ["/api/todos"] = new Regex(@"^/api/todos(/\d+)?$"),
        ["/api/users"] = new Regex(@"^/api/users(/\d+)?$"),
        ["/api/posts"] = new Regex(@"^/api/posts(/\d+)?$")
    };

    public bool IsValid(string endpoint)
    {
        if (string.IsNullOrWhiteSpace(endpoint))
            return false;

        // Check exact match first
        if (_allowedEndpoints.Contains(endpoint))
            return true;

        // Check regex patterns
        foreach (var (_, pattern) in _allowedPatterns)
        {
            if (pattern.IsMatch(endpoint))
                return true;
        }

        return false;
    }
}
```

### 3. Sanitize All User Inputs

**Input Sanitization Examples**:

```csharp
public class InputSanitizer
{
    // Sanitize for URL parameters
    public static string SanitizeUrlParameter(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return string.Empty;
        
        // Remove dangerous characters
        var sanitized = Regex.Replace(input, @"[^\w\s-]", "");
        
        // URL encode
        return Uri.EscapeDataString(sanitized);
    }

    // Sanitize for HTML context
    public static string SanitizeHtml(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return string.Empty;
        
        return WebUtility.HtmlEncode(input);
    }

    // Sanitize integer ID
    public static int? SanitizeId(object? input)
    {
        return input switch
        {
            int id when id > 0 => id,
            string str when int.TryParse(str, out var id) && id > 0 => id,
            _ => null
        };
    }

    // Sanitize search query
    public static string SanitizeSearchQuery(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return string.Empty;
        
        // Remove SQL injection attempts
        var sanitized = input.Replace("'", "")
                            .Replace("\"", "")
                            .Replace(";", "")
                            .Replace("--", "")
                            .Replace("/*", "")
                            .Replace("*/", "");
        
        // Limit length
        if (sanitized.Length > 100)
            sanitized = sanitized.Substring(0, 100);
        
        return sanitized.Trim();
    }
}
```

### 4. Implement Authorization Checks

**Authorization Pattern**:

```csharp
public interface IAuthorizationService
{
    Task<bool> CanAccessResourceAsync(string user, string resource, string action);
    Task<bool> CanAccessEndpointAsync(string user, string endpoint);
}

public class QueryAuthorizationService : IAuthorizationService
{
    private readonly IHttpContextAccessor _contextAccessor;
    private readonly ILogger<QueryAuthorizationService> _logger;

    public async Task<bool> CanAccessEndpointAsync(string user, string endpoint)
    {
        // Check user permissions
        var permissions = await GetUserPermissionsAsync(user);
        
        var resourceType = ExtractResourceType(endpoint);
        if (!permissions.Contains(resourceType))
        {
            _logger.LogWarning(
                "Authorization failed: User {User} cannot access {Resource}",
                user, resourceType
            );
            return false;
        }

        // Check row-level security if needed
        if (endpoint.Contains("/"))
        {
            var resourceId = ExtractResourceId(endpoint);
            if (resourceId.HasValue)
            {
                return await CanAccessSpecificResourceAsync(user, resourceType, resourceId.Value);
            }
        }

        return true;
    }

    private async Task<bool> CanAccessSpecificResourceAsync(
        string user, string resourceType, int resourceId)
    {
        // Implement row-level security
        // Check if user owns the resource or has appropriate role
        return resourceType switch
        {
            "todos" => await CanAccessTodoAsync(user, resourceId),
            "users" => await CanAccessUserAsync(user, resourceId),
            "posts" => await CanAccessPostAsync(user, resourceId),
            _ => false
        };
    }
}
```

### 5. Validate Response Data

**Data Validation Pattern**:

```csharp
public interface IDataValidator
{
    bool IsValid(object? data);
    object Sanitize(object data);
}

public class TodoDataValidator : IDataValidator
{
    public bool IsValid(object? data)
    {
        if (data is not Todo todo)
            return false;

        // Validate required fields
        if (string.IsNullOrWhiteSpace(todo.Title))
            return false;

        // Validate field lengths
        if (todo.Title.Length > 200)
            return false;

        // Validate ranges
        if (todo.Id < 0)
            return false;

        // Validate business rules
        if (todo.DueDate.HasValue && todo.DueDate < DateTime.UtcNow.AddYears(-1))
            return false;

        return true;
    }

    public object Sanitize(object data)
    {
        if (data is not Todo todo)
            return data;

        return new Todo
        {
            Id = todo.Id,
            Title = WebUtility.HtmlEncode(todo.Title.Trim()),
            Description = WebUtility.HtmlEncode(todo.Description?.Trim() ?? ""),
            Completed = todo.Completed,
            DueDate = todo.DueDate
        };
    }
}
```

## Complete Secure Implementation

### Production-Ready Secure Query Client

```csharp
public class SecureQueryClient
{
    private readonly HttpClient _httpClient;
    private readonly IAuthorizationService _authService;
    private readonly IDataValidator _dataValidator;
    private readonly SecureEndpointValidator _endpointValidator;
    private readonly IRateLimiter _rateLimiter;
    private readonly ILogger<SecureQueryClient> _logger;

    public QueryClient CreateSecureQueryClient()
    {
        return new QueryClient(
            logger: new MicrosoftExtensionsQueryLogger(_logger)
        )
        {
            DefaultQueryFn = SecureQueryFunction
        };
    }

    private async Task<object> SecureQueryFunction(QueryFunctionContext ctx)
    {
        var user = GetCurrentUser();
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();
        var startTime = DateTime.UtcNow;

        try
        {
            // ===== 1. RATE LIMITING =====
            if (!await _rateLimiter.AllowRequestAsync(user))
            {
                _logger.LogWarning(
                    "Rate limit exceeded: User={User}, Endpoint={Endpoint}",
                    user, endpoint
                );
                throw new RateLimitException($"Rate limit exceeded for user: {user}");
            }

            // ===== 2. INPUT VALIDATION =====
            if (string.IsNullOrWhiteSpace(endpoint))
            {
                _logger.LogWarning("Empty endpoint attempted by {User}", user);
                throw new ArgumentException("Endpoint cannot be empty");
            }

            // ===== 3. ENDPOINT WHITELIST =====
            if (!_endpointValidator.IsValid(endpoint))
            {
                _logger.LogWarning(
                    "Blocked non-whitelisted endpoint: User={User}, Endpoint={Endpoint}",
                    user, endpoint
                );
                throw new SecurityException($"Endpoint not allowed: {endpoint}");
            }

            // ===== 4. PARAMETER SANITIZATION =====
            var sanitizedEndpoint = SanitizeEndpoint(endpoint, ctx.QueryKey);

            // ===== 5. AUTHORIZATION CHECK =====
            if (!await _authService.CanAccessEndpointAsync(user, sanitizedEndpoint))
            {
                _logger.LogWarning(
                    "Authorization failed: User={User}, Endpoint={Endpoint}",
                    user, sanitizedEndpoint
                );
                throw new UnauthorizedAccessException(
                    $"User not authorized to access: {sanitizedEndpoint}"
                );
            }

            // ===== 6. EXECUTE REQUEST WITH TIMEOUT =====
            using var cts = CancellationTokenSource.CreateLinkedTokenSource(
                ctx.Signal,
                new CancellationTokenSource(TimeSpan.FromSeconds(30)).Token
            );

            _logger.LogInformation(
                "Executing secure query: User={User}, Endpoint={Endpoint}",
                user, sanitizedEndpoint
            );

            var response = await _httpClient.GetAsync(sanitizedEndpoint, cts.Token);
            
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogWarning(
                    "HTTP error {StatusCode} for {Endpoint}",
                    response.StatusCode, sanitizedEndpoint
                );
                response.EnsureSuccessStatusCode();
            }

            // ===== 7. RESPONSE VALIDATION =====
            var data = await response.Content.ReadFromJsonAsync<object>(
                cancellationToken: cts.Token
            );

            if (!_dataValidator.IsValid(data))
            {
                _logger.LogWarning(
                    "Data validation failed: User={User}, Endpoint={Endpoint}",
                    user, sanitizedEndpoint
                );
                throw new DataValidationException(
                    $"Response data validation failed for: {sanitizedEndpoint}"
                );
            }

            // ===== 8. DATA SANITIZATION =====
            var sanitizedData = _dataValidator.Sanitize(data);

            // ===== 9. AUDIT LOG SUCCESS =====
            var duration = DateTime.UtcNow - startTime;
            _logger.LogInformation(
                "Secure query completed: User={User}, Endpoint={Endpoint}, Duration={Duration}ms",
                user, sanitizedEndpoint, duration.TotalMilliseconds
            );

            return sanitizedData;
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation(
                "Query cancelled: User={User}, Endpoint={Endpoint}",
                user, endpoint
            );
            throw;
        }
        catch (RateLimitException)
        {
            // Already logged
            throw;
        }
        catch (UnauthorizedAccessException)
        {
            // Already logged
            throw;
        }
        catch (SecurityException)
        {
            // Already logged
            throw;
        }
        catch (Exception ex)
        {
            // Log unexpected errors without exposing sensitive details
            _logger.LogError(
                ex,
                "Secure query failed: User={User}, Endpoint={Endpoint}",
                user, endpoint
            );
            
            // Don't leak implementation details to client
            throw new QueryExecutionException(
                "An error occurred while executing the query",
                ex
            );
        }
    }

    private string SanitizeEndpoint(string endpoint, QueryKey queryKey)
    {
        // Build safe URL with sanitized parameters
        var builder = new StringBuilder(endpoint);
        
        for (int i = 1; i < queryKey.Parts.Count; i++)
        {
            var param = queryKey.Parts[i];
            
            // Sanitize based on type
            var sanitized = param switch
            {
                int id when id > 0 => id.ToString(),
                string str => InputSanitizer.SanitizeUrlParameter(str),
                _ => throw new ArgumentException($"Invalid parameter type at position {i}")
            };
            
            builder.Append('/').Append(sanitized);
        }
        
        return builder.ToString();
    }

    private string GetCurrentUser()
    {
        return _httpContextAccessor.HttpContext?.User?.Identity?.Name 
               ?? throw new UnauthorizedAccessException("User not authenticated");
    }
}
```

### Rate Limiter Implementation

```csharp
public interface IRateLimiter
{
    Task<bool> AllowRequestAsync(string user);
}

public class SlidingWindowRateLimiter : IRateLimiter
{
    private readonly ConcurrentDictionary<string, Queue<DateTime>> _requests = new();
    private readonly int _maxRequests;
    private readonly TimeSpan _window;

    public SlidingWindowRateLimiter(int maxRequests = 100, TimeSpan? window = null)
    {
        _maxRequests = maxRequests;
        _window = window ?? TimeSpan.FromMinutes(1);
    }

    public Task<bool> AllowRequestAsync(string user)
    {
        var now = DateTime.UtcNow;
        var requests = _requests.GetOrAdd(user, _ => new Queue<DateTime>());

        lock (requests)
        {
            // Remove old requests outside the window
            while (requests.Count > 0 && (now - requests.Peek()) > _window)
            {
                requests.Dequeue();
            }

            // Check if limit exceeded
            if (requests.Count >= _maxRequests)
            {
                return Task.FromResult(false);
            }

            // Allow request
            requests.Enqueue(now);
            return Task.FromResult(true);
        }
    }
}
```

## Security Checklist

Before deploying to production, verify:

### ‚úÖ Input Validation
- [ ] All endpoints validated against whitelist
- [ ] All user inputs sanitized
- [ ] Parameter types validated
- [ ] Parameter ranges checked
- [ ] String lengths limited

### ‚úÖ Authorization
- [ ] User authentication required
- [ ] Permission checks implemented
- [ ] Row-level security enforced
- [ ] Role-based access control (RBAC)
- [ ] Audit logging for auth failures

### ‚úÖ Data Validation
- [ ] Response data validated
- [ ] Required fields checked
- [ ] Data types verified
- [ ] Business rules enforced
- [ ] Data sanitized before use

### ‚úÖ Network Security
- [ ] HTTPS enforced
- [ ] Request timeouts configured
- [ ] Rate limiting implemented
- [ ] CORS configured correctly
- [ ] API keys secured

### ‚úÖ Error Handling
- [ ] Sensitive data not leaked in errors
- [ ] Generic error messages to clients
- [ ] Detailed logging for debugging
- [ ] Exception types not exposed
- [ ] Stack traces hidden from clients

### ‚úÖ Logging & Monitoring
- [ ] All operations audit logged
- [ ] Security events monitored
- [ ] Failed auth attempts tracked
- [ ] Anomaly detection configured
- [ ] Log retention policy set

---

## Summary

‚úÖ **Validate Everything**: Never trust external data  
‚úÖ **Whitelist Endpoints**: Only allow known endpoints  
‚úÖ **Sanitize Inputs**: Clean all user inputs  
‚úÖ **Check Authorization**: Verify permissions before access  
‚úÖ **Validate Responses**: Ensure data meets business rules  
‚úÖ **Rate Limiting**: Prevent abuse  
‚úÖ **Audit Logging**: Track all security events  
‚úÖ **Error Handling**: Don't leak sensitive information  

**‚ö†Ô∏è CRITICAL**: BlazorQuery provides the infrastructure, but **YOU are responsible for implementing security in your query functions!**

**Security is not optional - it's essential!** üõ°Ô∏è

