# Logging and Error Handling

BlazorQuery provides comprehensive logging and error handling capabilities for production applications. This includes audit logging, diagnostic information, and robust error handling.

## IQueryLogger Interface

BlazorQuery uses the `IQueryLogger` interface for all logging operations. This allows you to integrate with any logging framework (Serilog, NLog, Microsoft.Extensions.Logging, etc.).

```csharp
public interface IQueryLogger
{
    void LogDebug(string message, params object[] args);
    void LogInformation(string message, params object[] args);
    void LogWarning(string message, params object[] args);
    void LogError(Exception exception, string message, params object[] args);
    void LogCritical(Exception exception, string message, params object[] args);
}
```

## Built-in Loggers

### NullQueryLogger (Default)

By default, BlazorQuery uses `NullQueryLogger` which does nothing. This ensures zero overhead when logging is not needed.

```csharp
var queryClient = new QueryClient();
// Uses NullQueryLogger by default - no logging
```

### ConsoleQueryLogger

For debugging, use `ConsoleQueryLogger`:

```csharp
var queryClient = new QueryClient(logger: new ConsoleQueryLogger());
```

## Integration with Microsoft.Extensions.Logging

Create a wrapper to integrate with Microsoft.Extensions.Logging:

```csharp
using Microsoft.Extensions.Logging;

public class MicrosoftExtensionsQueryLogger : IQueryLogger
{
    private readonly ILogger<QueryClient> _logger;

    public MicrosoftExtensionsQueryLogger(ILogger<QueryClient> logger)
    {
        _logger = logger;
    }

    public void LogDebug(string message, params object[] args)
    {
        _logger.LogDebug(message, args);
    }

    public void LogInformation(string message, params object[] args)
    {
        _logger.LogInformation(message, args);
    }

    public void LogWarning(string message, params object[] args)
    {
        _logger.LogWarning(message, args);
    }

    public void LogError(Exception exception, string message, params object[] args)
    {
        _logger.LogError(exception, message, args);
    }

    public void LogCritical(Exception exception, string message, params object[] args)
    {
        _logger.LogCritical(exception, message, args);
    }
}

// Usage in Blazor Server
builder.Services.AddSingleton<QueryClient>(sp => {
    var logger = sp.GetRequiredService<ILogger<QueryClient>>();
    return new QueryClient(logger: new MicrosoftExtensionsQueryLogger(logger));
});
```

## Integration with Serilog

```csharp
using Serilog;

public class SerilogQueryLogger : IQueryLogger
{
    private readonly ILogger _logger;

    public SerilogQueryLogger(ILogger logger)
    {
        _logger = logger;
    }

    public void LogDebug(string message, params object[] args)
    {
        _logger.Debug(message, args);
    }

    public void LogInformation(string message, params object[] args)
    {
        _logger.Information(message, args);
    }

    public void LogWarning(string message, params object[] args)
    {
        _logger.Warning(message, args);
    }

    public void LogError(Exception exception, string message, params object[] args)
    {
        _logger.Error(exception, message, args);
    }

    public void LogCritical(Exception exception, string message, params object[] args)
    {
        _logger.Fatal(exception, message, args);
    }
}

// Usage
var serilogLogger = new LoggerConfiguration()
    .WriteTo.File("logs/blazorquery.log")
    .CreateLogger();

var queryClient = new QueryClient(logger: new SerilogQueryLogger(serilogLogger));
```

## What Gets Logged

### Query Invalidation

```csharp
// Information level
Invalidating 5 queries. Filter: QueryKey=todos, Exact=False, Type=All

// Debug level (per query)
Invalidated query: todos
Invalidated query: todos/1
Invalidated query: todos/2

// Information level
Query invalidation completed. 5 queries invalidated.
```

### Query Cancellation

```csharp
// Information level
Cancelling 3 queries. Filter: QueryKey=todos, Silent=False, Revert=True

// Information level (per query affected)
Cancelling query: todos

// Information level
Query cancellation completed. 3 queries notified.
```

### Query Execution

```csharp
// Debug level
Using default query function for: todos

// Debug level
Executing default query function for: todos

// Debug level
Default query function succeeded for: todos, ResultType=List`1
```

### Error Scenarios

```csharp
// Error level
Error during query invalidation: System.ArgumentException: Invalid filter...

// Error level
Error handling query cancellation for: todos

// Error level
Type mismatch in default query function for: todos
```

## Audit Logging Example

For compliance and security auditing, integrate with your audit system:

```csharp
public class AuditQueryLogger : IQueryLogger
{
    private readonly IAuditService _auditService;
    private readonly ILogger _logger;

    public AuditQueryLogger(IAuditService auditService, ILogger logger)
    {
        _auditService = auditService;
        _logger = logger;
    }

    public void LogInformation(string message, params object[] args)
    {
        var formattedMessage = string.Format(message, args);
        _logger.LogInformation(formattedMessage);
        
        // Audit critical operations
        if (message.Contains("Invalidating") || message.Contains("Cancelling"))
        {
            _auditService.LogOperation(new AuditRecord
            {
                Timestamp = DateTime.UtcNow,
                Operation = "QueryOperation",
                Details = formattedMessage,
                User = GetCurrentUser()
            });
        }
    }

    // ... other methods
}
```

## Error Handling Best Practices

### 1. Event Handler Errors

BlazorQuery catches and logs errors in event handlers to prevent crashes:

```csharp
// Focus change handler
_focusChangedHandler = async void (isFocused) =>
{
    try
    {
        await HandleFocusChangedAsync(isFocused);
    }
    catch (OperationCanceledException)
    {
        // Expected - query cancelled
        _client.Logger.LogDebug("Focus refetch cancelled for query: {QueryKey}", _queryOptions.QueryKey);
    }
    catch (Exception ex)
    {
        // Unexpected error - log but don't crash
        _client.Logger.LogError(ex, "Error during focus change handling for query: {QueryKey}", _queryOptions.QueryKey);
    }
};
```

### 2. Query Invalidation Errors

```csharp
private void HandleQueriesInvalidated(List<QueryKey> invalidatedKeys)
{
    try
    {
        // ... handle invalidation
    }
    catch (Exception ex)
    {
        _client.Logger.LogError(ex, "Error handling query invalidation for: {QueryKey}", _queryOptions.QueryKey);
        // Don't propagate - this is called from an event handler
    }
}
```

### 3. Default Query Function Validation

```csharp
// Validate result is not null for value types
if (result == null && typeof(T).IsValueType && Nullable.GetUnderlyingType(typeof(T)) == null)
{
    var ex = new InvalidOperationException(
        $"Default query function returned null for non-nullable value type {typeof(T).Name}"
    );
    _client.Logger.LogError(ex, "Validation error in default query function");
    throw ex;
}

// Type checking
if (result is T typedResult)
{
    return typedResult;
}

var castEx = new InvalidCastException(
    $"Default query function returned {result?.GetType().Name ?? "null"} " +
    $"but expected {typeof(T).Name}"
);
_client.Logger.LogError(castEx, "Type mismatch in default query function");
throw castEx;
```

## Complete Example with Logging

```csharp
public class ProductionApp
{
    private readonly QueryClient _queryClient;
    private readonly ILogger<ProductionApp> _logger;

    public ProductionApp(ILogger<ProductionApp> logger, ILogger<QueryClient> queryLogger)
    {
        _logger = logger;
        
        // Setup QueryClient with logging
        _queryClient = new QueryClient(
            logger: new MicrosoftExtensionsQueryLogger(queryLogger)
        );
        
        _logger.LogInformation("QueryClient initialized with logging");
    }

    public async Task<List<Todo>> GetTodosAsync()
    {
        var query = new UseQuery<List<Todo>>(
            new QueryOptions<List<Todo>>(
                queryKey: new("todos"),
                queryFn: async ctx => {
                    _logger.LogDebug("Fetching todos from API");
                    
                    try
                    {
                        var response = await HttpClient.GetAsync("/api/todos", ctx.Signal);
                        response.EnsureSuccessStatusCode();
                        
                        var todos = await response.Content
                            .ReadFromJsonAsync<List<Todo>>(cancellationToken: ctx.Signal)
                            ?? new List<Todo>();
                        
                        _logger.LogInformation("Successfully fetched {Count} todos", todos.Count);
                        return todos;
                    }
                    catch (HttpRequestException ex)
                    {
                        _logger.LogError(ex, "HTTP error fetching todos");
                        throw;
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Unexpected error fetching todos");
                        throw;
                    }
                },
                staleTime: TimeSpan.FromMinutes(5)
            ),
            _queryClient
        );

        await query.ExecuteAsync();
        return query.Data ?? new List<Todo>();
    }

    public void InvalidateTodos()
    {
        _logger.LogInformation("User requested to invalidate todos");
        
        // This will log:
        // [INFO] Invalidating X queries. Filter: QueryKey=todos, Exact=False, Type=All
        // [DEBUG] Invalidated query: todos
        // [INFO] Query invalidation completed. X queries invalidated.
        _queryClient.InvalidateQueries(new QueryFilters
        {
            QueryKey = new("todos")
        });
    }

    public void CancelAllQueries()
    {
        _logger.LogWarning("User requested to cancel all queries");
        
        // This will log:
        // [INFO] Cancelling X queries. Filter: QueryKey=null, Silent=False, Revert=True
        // [INFO] Query cancellation completed. X queries notified.
        _queryClient.CancelQueries();
    }
}
```

## Structured Logging with Query Context

For better diagnostics, always include query key in log messages:

```csharp
_client.Logger.LogInformation(
    "Query {Operation} for {QueryKey} by {User}",
    "Invalidation",
    _queryOptions.QueryKey,
    GetCurrentUser()
);
```

This produces structured logs that can be queried:

```json
{
  "Timestamp": "2024-01-15T10:30:00Z",
  "Level": "Information",
  "Message": "Query Invalidation for todos by john@example.com",
  "Properties": {
    "Operation": "Invalidation",
    "QueryKey": "todos",
    "User": "john@example.com"
  }
}
```

## Performance Monitoring

Use logging to track query performance:

```csharp
public class PerformanceQueryLogger : IQueryLogger
{
    private readonly IMetricsService _metrics;

    public void LogInformation(string message, params object[] args)
    {
        if (message.Contains("completed"))
        {
            // Extract metrics from message
            _metrics.RecordOperation("query_completed");
        }
    }

    // ... other methods
}
```

---

## Summary

âœ… **IQueryLogger Interface**: Pluggable logging system  
âœ… **Built-in Loggers**: Null (default) and Console  
âœ… **Easy Integration**: Microsoft.Extensions.Logging, Serilog, etc.  
âœ… **Audit Logging**: All operations logged with context  
âœ… **Error Handling**: Robust error handling with meaningful messages  
âœ… **Structured Logging**: Query keys and context in all logs  
âœ… **Security**: Audit trail for compliance  
âœ… **Performance**: Track query operations and timing  

**BlazorQuery provides production-ready logging and error handling!** ðŸ“Š

