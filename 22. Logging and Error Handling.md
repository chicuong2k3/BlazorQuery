# Logging and Error Handling

BlazorQuery provides comprehensive logging and error handling capabilities for production applications. This includes audit logging, diagnostic information, and robust error handling.

## IQueryLogger Interface

BlazorQuery uses the `IQueryLogger` interface for all logging operations. This allows you to integrate with any logging framework (Serilog, NLog, Microsoft.Extensions.Logging, etc.).

```csharp
public interface IQueryLogger
{
    void LogDebug(string message, params object[] args);
    void LogInformation(string message, params object[] args);
    void LogWarning(string message, params object[] args);
    void LogError(Exception exception, string message, params object[] args);
    void LogCritical(Exception exception, string message, params object[] args);
}
```

## Built-in Loggers

### NullQueryLogger (Default)

By default, BlazorQuery uses `NullQueryLogger` which does nothing. This ensures zero overhead when logging is not needed.

```csharp
var queryClient = new QueryClient();
// Uses NullQueryLogger by default - no logging
```

### ConsoleQueryLogger

For debugging, use `ConsoleQueryLogger`:

```csharp
var queryClient = new QueryClient(logger: new ConsoleQueryLogger());
```

## Integration with Microsoft.Extensions.Logging

Create a wrapper to integrate with Microsoft.Extensions.Logging:

```csharp
using Microsoft.Extensions.Logging;

public class MicrosoftExtensionsQueryLogger : IQueryLogger
{
    private readonly ILogger<QueryClient> _logger;

    public MicrosoftExtensionsQueryLogger(ILogger<QueryClient> logger)
    {
        _logger = logger;
    }

    public void LogDebug(string message, params object[] args)
    {
        _logger.LogDebug(message, args);
    }

    public void LogInformation(string message, params object[] args)
    {
        _logger.LogInformation(message, args);
    }

    public void LogWarning(string message, params object[] args)
    {
        _logger.LogWarning(message, args);
    }

    public void LogError(Exception exception, string message, params object[] args)
    {
        _logger.LogError(exception, message, args);
    }

    public void LogCritical(Exception exception, string message, params object[] args)
    {
        _logger.LogCritical(exception, message, args);
    }
}

// Usage in Blazor Server
builder.Services.AddSingleton<QueryClient>(sp => {
    var logger = sp.GetRequiredService<ILogger<QueryClient>>();
    return new QueryClient(logger: new MicrosoftExtensionsQueryLogger(logger));
});
```

## Integration with Serilog

```csharp
using Serilog;

public class SerilogQueryLogger : IQueryLogger
{
    private readonly ILogger _logger;

    public SerilogQueryLogger(ILogger logger)
    {
        _logger = logger;
    }

    public void LogDebug(string message, params object[] args)
    {
        _logger.Debug(message, args);
    }

    public void LogInformation(string message, params object[] args)
    {
        _logger.Information(message, args);
    }

    public void LogWarning(string message, params object[] args)
    {
        _logger.Warning(message, args);
    }

    public void LogError(Exception exception, string message, params object[] args)
    {
        _logger.Error(exception, message, args);
    }

    public void LogCritical(Exception exception, string message, params object[] args)
    {
        _logger.Fatal(exception, message, args);
    }
}

// Usage
var serilogLogger = new LoggerConfiguration()
    .WriteTo.File("logs/blazorquery.log")
    .CreateLogger();

var queryClient = new QueryClient(logger: new SerilogQueryLogger(serilogLogger));
```

## What Gets Logged

### Query Invalidation

```csharp
// Information level
Invalidating 5 queries. Filter: QueryKey=todos, Exact=False, Type=All

// Debug level (per query)
Invalidated query: todos
Invalidated query: todos/1
Invalidated query: todos/2

// Information level
Query invalidation completed. 5 queries invalidated.
```

### Query Cancellation

```csharp
// Information level
Cancelling 3 queries. Filter: QueryKey=todos, Silent=False, Revert=True

// Information level (per query affected)
Cancelling query: todos

// Information level
Query cancellation completed. 3 queries notified.
```

### Query Execution

```csharp
// Debug level
Using default query function for: todos

// Debug level
Executing default query function for: todos

// Debug level
Default query function succeeded for: todos, ResultType=List`1
```

### Error Scenarios

```csharp
// Error level
Error during query invalidation: System.ArgumentException: Invalid filter...

// Error level
Error handling query cancellation for: todos

// Error level
Type mismatch in default query function for: todos
```

## Audit Logging Example

For compliance and security auditing, integrate with your audit system:

```csharp
public class AuditQueryLogger : IQueryLogger
{
    private readonly IAuditService _auditService;
    private readonly ILogger _logger;

    public AuditQueryLogger(IAuditService auditService, ILogger logger)
    {
        _auditService = auditService;
        _logger = logger;
    }

    public void LogInformation(string message, params object[] args)
    {
        var formattedMessage = string.Format(message, args);
        _logger.LogInformation(formattedMessage);
        
        // Audit critical operations
        if (message.Contains("Invalidating") || message.Contains("Cancelling"))
        {
            _auditService.LogOperation(new AuditRecord
            {
                Timestamp = DateTime.UtcNow,
                Operation = "QueryOperation",
                Details = formattedMessage,
                User = GetCurrentUser()
            });
        }
    }

    // ... other methods
}
```

## Error Handling Best Practices

### 1. Event Handler Errors

BlazorQuery catches and logs errors in event handlers to prevent crashes:

```csharp
// Focus change handler
_focusChangedHandler = async void (isFocused) =>
{
    try
    {
        await HandleFocusChangedAsync(isFocused);
    }
    catch (OperationCanceledException)
    {
        // Expected - query cancelled
        _client.Logger.LogDebug("Focus refetch cancelled for query: {QueryKey}", _queryOptions.QueryKey);
    }
    catch (Exception ex)
    {
        // Unexpected error - log but don't crash
        _client.Logger.LogError(ex, "Error during focus change handling for query: {QueryKey}", _queryOptions.QueryKey);
    }
};
```

### 2. Query Invalidation Errors

```csharp
private void HandleQueriesInvalidated(List<QueryKey> invalidatedKeys)
{
    try
    {
        // ... handle invalidation
    }
    catch (Exception ex)
    {
        _client.Logger.LogError(ex, "Error handling query invalidation for: {QueryKey}", _queryOptions.QueryKey);
        // Don't propagate - this is called from an event handler
    }
}
```

### 3. Default Query Function Validation

```csharp
// Validate result is not null for value types
if (result == null && typeof(T).IsValueType && Nullable.GetUnderlyingType(typeof(T)) == null)
{
    var ex = new InvalidOperationException(
        $"Default query function returned null for non-nullable value type {typeof(T).Name}"
    );
    _client.Logger.LogError(ex, "Validation error in default query function");
    throw ex;
}

// Type checking
if (result is T typedResult)
{
    return typedResult;
}

var castEx = new InvalidCastException(
    $"Default query function returned {result?.GetType().Name ?? "null"} " +
    $"but expected {typeof(T).Name}"
);
_client.Logger.LogError(castEx, "Type mismatch in default query function");
throw castEx;
```

## Complete Example with Logging

```csharp
public class ProductionApp
{
    private readonly QueryClient _queryClient;
    private readonly ILogger<ProductionApp> _logger;

    public ProductionApp(ILogger<ProductionApp> logger, ILogger<QueryClient> queryLogger)
    {
        _logger = logger;
        
        // Setup QueryClient with logging
        _queryClient = new QueryClient(
            logger: new MicrosoftExtensionsQueryLogger(queryLogger)
        );
        
        _logger.LogInformation("QueryClient initialized with logging");
    }

    public async Task<List<Todo>> GetTodosAsync()
    {
        var query = new UseQuery<List<Todo>>(
            new QueryOptions<List<Todo>>(
                queryKey: new("todos"),
                queryFn: async ctx => {
                    _logger.LogDebug("Fetching todos from API");
                    
                    try
                    {
                        var response = await HttpClient.GetAsync("/api/todos", ctx.Signal);
                        response.EnsureSuccessStatusCode();
                        
                        var todos = await response.Content
                            .ReadFromJsonAsync<List<Todo>>(cancellationToken: ctx.Signal)
                            ?? new List<Todo>();
                        
                        _logger.LogInformation("Successfully fetched {Count} todos", todos.Count);
                        return todos;
                    }
                    catch (HttpRequestException ex)
                    {
                        _logger.LogError(ex, "HTTP error fetching todos");
                        throw;
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Unexpected error fetching todos");
                        throw;
                    }
                },
                staleTime: TimeSpan.FromMinutes(5)
            ),
            _queryClient
        );

        await query.ExecuteAsync();
        return query.Data ?? new List<Todo>();
    }

    public void InvalidateTodos()
    {
        _logger.LogInformation("User requested to invalidate todos");
        
        // This will log:
        // [INFO] Invalidating X queries. Filter: QueryKey=todos, Exact=False, Type=All
        // [DEBUG] Invalidated query: todos
        // [INFO] Query invalidation completed. X queries invalidated.
        _queryClient.InvalidateQueries(new QueryFilters
        {
            QueryKey = new("todos")
        });
    }

    public void CancelAllQueries()
    {
        _logger.LogWarning("User requested to cancel all queries");
        
        // This will log:
        // [INFO] Cancelling X queries. Filter: QueryKey=null, Silent=False, Revert=True
        // [INFO] Query cancellation completed. X queries notified.
        _queryClient.CancelQueries();
    }
}
```

## Structured Logging with Query Context

For better diagnostics, always include query key in log messages:

```csharp
_client.Logger.LogInformation(
    "Query {Operation} for {QueryKey} by {User}",
    "Invalidation",
    _queryOptions.QueryKey,
    GetCurrentUser()
);
```

This produces structured logs that can be queried:

```json
{
  "Timestamp": "2024-01-15T10:30:00Z",
  "Level": "Information",
  "Message": "Query Invalidation for todos by john@example.com",
  "Properties": {
    "Operation": "Invalidation",
    "QueryKey": "todos",
    "User": "john@example.com"
  }
}
```

## Performance Monitoring

Use logging to track query performance:

```csharp
public class PerformanceQueryLogger : IQueryLogger
{
    private readonly IMetricsService _metrics;

    public void LogInformation(string message, params object[] args)
    {
        if (message.Contains("completed"))
        {
            // Extract metrics from message
            _metrics.RecordOperation("query_completed");
        }
    }

    // ... other methods
}
```

## Security Considerations

### Input Validation and Sanitization

BlazorQuery provides built-in validation for DefaultQueryFn, but **you are responsible for validating and sanitizing data in your query functions**.

#### Built-in Validation

When using DefaultQueryFn, BlazorQuery automatically:

1. **Validates non-null constraints**:
```csharp
// Automatically validates value types cannot be null
if (result == null && typeof(T).IsValueType && Nullable.GetUnderlyingType(typeof(T)) == null)
{
    var ex = new InvalidOperationException(
        $"Default query function returned null for non-nullable value type {typeof(T).Name}"
    );
    _client.Logger.LogError(ex, "Validation error in default query function");
    throw ex;
}
```

2. **Validates type safety**:
```csharp
// Automatically checks type compatibility
if (result is T typedResult)
{
    return typedResult;
}

var castEx = new InvalidCastException(
    $"Default query function returned {result?.GetType().Name ?? "null"} " +
    $"but expected {typeof(T).Name}"
);
_client.Logger.LogError(castEx, "Type mismatch in default query function");
throw castEx;
```

3. **Logs all operations** for audit trail.

#### Your Responsibility: Data Validation

**‚ö†Ô∏è IMPORTANT**: BlazorQuery validates types, but you must validate and sanitize **data content** in your query functions:

```csharp
public class SecureQueryClient
{
    private readonly HttpClient _httpClient;
    private readonly IDataValidator _validator;
    private readonly ILogger _logger;

    public SecureQueryClient(HttpClient httpClient, IDataValidator validator, ILogger logger)
    {
        _httpClient = httpClient;
        _validator = validator;
        _logger = logger;
    }

    public QueryClient CreateQueryClient()
    {
        return new QueryClient(
            logger: new MicrosoftExtensionsQueryLogger(_logger)
        )
        {
            DefaultQueryFn = async ctx => {
                // 1. Log query attempt with context
                _logger.LogInformation(
                    "Executing query for {QueryKey} by {User}",
                    ctx.QueryKey,
                    GetCurrentUser()
                );

                // 2. Extract and validate endpoint
                var endpoint = ctx.QueryKey.Parts[0]?.ToString();
                if (string.IsNullOrWhiteSpace(endpoint))
                {
                    _logger.LogWarning("Invalid query key: empty endpoint");
                    throw new ArgumentException("Query key must contain valid endpoint");
                }

                // 3. Sanitize endpoint to prevent injection
                if (!IsValidEndpoint(endpoint))
                {
                    _logger.LogWarning(
                        "Potential security issue: invalid endpoint {Endpoint}",
                        endpoint
                    );
                    throw new SecurityException($"Invalid endpoint: {endpoint}");
                }

                // 4. Check authorization
                if (!await IsAuthorizedAsync(endpoint, GetCurrentUser()))
                {
                    _logger.LogWarning(
                        "Unauthorized access attempt to {Endpoint} by {User}",
                        endpoint,
                        GetCurrentUser()
                    );
                    throw new UnauthorizedAccessException(
                        $"User not authorized to access: {endpoint}"
                    );
                }

                // 5. Fetch data
                var response = await _httpClient.GetAsync(endpoint, ctx.Signal);
                response.EnsureSuccessStatusCode();
                
                var data = await response.Content.ReadFromJsonAsync<object>(
                    cancellationToken: ctx.Signal
                );

                // 6. Validate response data
                if (!_validator.IsValid(data))
                {
                    _logger.LogWarning(
                        "Data validation failed for {Endpoint}",
                        endpoint
                    );
                    throw new DataValidationException("Response data validation failed");
                }

                // 7. Sanitize data before returning
                var sanitizedData = _validator.Sanitize(data);

                _logger.LogInformation(
                    "Successfully fetched and validated data for {Endpoint}",
                    endpoint
                );

                return sanitizedData;
            }
        };
    }

    private bool IsValidEndpoint(string endpoint)
    {
        // Whitelist approach - only allow known patterns
        var allowedPatterns = new[]
        {
            @"^/api/todos(/\d+)?$",
            @"^/api/users(/\d+)?$",
            @"^/api/posts(/\d+)?$"
        };

        return allowedPatterns.Any(pattern => 
            System.Text.RegularExpressions.Regex.IsMatch(endpoint, pattern)
        );
    }

    private async Task<bool> IsAuthorizedAsync(string endpoint, string user)
    {
        // Check user permissions for endpoint
        // This is YOUR responsibility to implement
        return await _authService.CheckPermissionAsync(user, endpoint);
    }

    private string GetCurrentUser()
    {
        // Get current user from context
        // This is YOUR responsibility to implement
        return _httpContextAccessor.HttpContext?.User?.Identity?.Name ?? "anonymous";
    }
}
```

### Security Best Practices

#### 1. **Whitelist Endpoints**

```csharp
// ‚úÖ GOOD: Whitelist allowed endpoints
var allowedEndpoints = new HashSet<string>
{
    "/api/todos",
    "/api/users",
    "/api/posts"
};

if (!allowedEndpoints.Contains(endpoint))
{
    _logger.LogWarning("Blocked unauthorized endpoint: {Endpoint}", endpoint);
    throw new SecurityException("Endpoint not allowed");
}

// ‚ùå BAD: Allow any endpoint
var data = await httpClient.GetAsync(endpoint); // Dangerous!
```

#### 2. **Validate Query Parameters**

```csharp
// ‚úÖ GOOD: Validate parameters
var id = ctx.QueryKey.Parts[1];
if (id is not int validId || validId <= 0)
{
    _logger.LogWarning("Invalid ID parameter: {Id}", id);
    throw new ArgumentException("ID must be positive integer");
}

// ‚ùå BAD: Use parameter directly
var url = $"/api/todos/{ctx.QueryKey.Parts[1]}"; // SQL injection risk!
```

#### 3. **Sanitize User Input**

```csharp
// ‚úÖ GOOD: Sanitize input
var searchTerm = ctx.QueryKey.Parts[1]?.ToString();
var sanitized = WebUtility.HtmlEncode(searchTerm);
var url = $"/api/search?q={Uri.EscapeDataString(sanitized)}";

// ‚ùå BAD: Use raw input
var url = $"/api/search?q={ctx.QueryKey.Parts[1]}"; // XSS risk!
```

#### 4. **Implement Authorization Checks**

```csharp
// ‚úÖ GOOD: Check authorization
var resourceId = (int)ctx.QueryKey.Parts[1]!;
if (!await CanAccessResourceAsync(currentUser, resourceId))
{
    _logger.LogWarning(
        "Unauthorized access attempt: User={User}, Resource={Resource}",
        currentUser,
        resourceId
    );
    throw new UnauthorizedAccessException();
}

// ‚ùå BAD: No authorization check
var data = await FetchResourceAsync(resourceId); // Anyone can access!
```

#### 5. **Validate Response Data**

```csharp
// ‚úÖ GOOD: Validate response
var data = await response.Content.ReadFromJsonAsync<Todo>();
if (data == null || string.IsNullOrWhiteSpace(data.Title))
{
    _logger.LogWarning("Invalid response data");
    throw new DataValidationException("Invalid todo data");
}

// ‚ùå BAD: Trust all data
return data; // Could be malicious!
```

#### 6. **Rate Limiting**

```csharp
// ‚úÖ GOOD: Implement rate limiting
public class RateLimitedQueryLogger : IQueryLogger
{
    private readonly ConcurrentDictionary<string, (DateTime, int)> _rateLimits = new();

    public void LogInformation(string message, params object[] args)
    {
        if (message.Contains("Executing query"))
        {
            var user = GetCurrentUser();
            var (lastReset, count) = _rateLimits.GetOrAdd(user, (DateTime.UtcNow, 0));

            if ((DateTime.UtcNow - lastReset).TotalMinutes > 1)
            {
                _rateLimits[user] = (DateTime.UtcNow, 1);
            }
            else if (count > 100) // 100 queries per minute
            {
                _logger.LogWarning("Rate limit exceeded for user: {User}", user);
                throw new RateLimitException($"Rate limit exceeded for user: {user}");
            }
            else
            {
                _rateLimits[user] = (lastReset, count + 1);
            }
        }
    }
}
```

### Security Checklist

When implementing DefaultQueryFn, ensure:

- [ ] **Endpoint validation**: Whitelist allowed endpoints
- [ ] **Parameter sanitization**: Clean all user inputs
- [ ] **Authorization checks**: Verify user permissions
- [ ] **Data validation**: Validate response data
- [ ] **Error handling**: Don't leak sensitive info in errors
- [ ] **Audit logging**: Log all security events
- [ ] **Rate limiting**: Prevent abuse
- [ ] **HTTPS**: Always use secure connections
- [ ] **Input encoding**: Prevent XSS/SQL injection
- [ ] **Timeout limits**: Prevent DoS attacks

### Example: Production-Ready Secure Query Function

```csharp
public class ProductionSecureQueryFn
{
    private readonly HttpClient _httpClient;
    private readonly IAuthorizationService _authService;
    private readonly IDataValidator _validator;
    private readonly ILogger _logger;
    private readonly IRateLimiter _rateLimiter;

    public async Task<object> ExecuteAsync(QueryFunctionContext ctx)
    {
        var user = GetCurrentUser();
        var endpoint = ctx.QueryKey.Parts[0]?.ToString();

        try
        {
            // 1. Rate limiting
            await _rateLimiter.CheckRateLimitAsync(user);

            // 2. Validate endpoint format
            if (!IsValidEndpointFormat(endpoint))
            {
                _logger.LogWarning(
                    "Invalid endpoint format: {Endpoint} by {User}",
                    endpoint, user
                );
                throw new ArgumentException("Invalid endpoint format");
            }

            // 3. Whitelist check
            if (!IsWhitelisted(endpoint))
            {
                _logger.LogWarning(
                    "Blocked non-whitelisted endpoint: {Endpoint} by {User}",
                    endpoint, user
                );
                throw new SecurityException("Endpoint not allowed");
            }

            // 4. Authorization check
            if (!await _authService.IsAuthorizedAsync(user, endpoint))
            {
                _logger.LogWarning(
                    "Authorization failed: {User} accessing {Endpoint}",
                    user, endpoint
                );
                throw new UnauthorizedAccessException();
            }

            // 5. Sanitize parameters
            var sanitizedParams = SanitizeQueryParameters(ctx.QueryKey);

            // 6. Build safe URL
            var url = BuildSafeUrl(endpoint, sanitizedParams);

            // 7. Execute request with timeout
            using var cts = CancellationTokenSource.CreateLinkedTokenSource(
                ctx.Signal,
                new CancellationTokenSource(TimeSpan.FromSeconds(30)).Token
            );

            var response = await _httpClient.GetAsync(url, cts.Token);
            response.EnsureSuccessStatusCode();

            // 8. Validate response
            var data = await response.Content.ReadFromJsonAsync<object>(
                cancellationToken: cts.Token
            );

            if (!_validator.IsValid(data))
            {
                _logger.LogWarning("Data validation failed for {Endpoint}", endpoint);
                throw new DataValidationException();
            }

            // 9. Sanitize response
            var sanitizedData = _validator.Sanitize(data);

            // 10. Audit log success
            _logger.LogInformation(
                "Secure query executed: {User} accessed {Endpoint}",
                user, endpoint
            );

            return sanitizedData;
        }
        catch (Exception ex)
        {
            // Don't leak sensitive information
            _logger.LogError(ex, "Query execution failed for {Endpoint}", endpoint);
            throw new QueryExecutionException("Query execution failed", ex);
        }
    }
}
```

---

## Summary

‚úÖ **IQueryLogger Interface**: Pluggable logging system  
‚úÖ **Built-in Loggers**: Null (default) and Console  
‚úÖ **Easy Integration**: Microsoft.Extensions.Logging, Serilog, etc.  
‚úÖ **Audit Logging**: All operations logged with context  
‚úÖ **Error Handling**: Robust error handling with meaningful messages  
‚úÖ **Structured Logging**: Query keys and context in all logs  
‚úÖ **Security**: Input validation, authorization, audit trail  
‚úÖ **Performance**: Track query operations and timing  

**‚ö†Ô∏è Security Reminder**: BlazorQuery validates types and logs operations, but **YOU must validate data content, implement authorization, and sanitize inputs in your query functions!**

**BlazorQuery provides production-ready logging, error handling, and security foundations!** üìäüõ°Ô∏è

